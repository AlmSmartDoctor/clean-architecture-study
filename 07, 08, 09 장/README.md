# 진행 자료
# 개요
**SOLID 원칙이란?**

- 로바트 마틴이 기술한 5가지 객체지향프로그래밍의 5가지 법칙의 두문자어를 따온 것
- 좋은 소프트웨어는 깔끔한 코드(clean code)로부터 시작한다. 따라서, 좋은 아키텍처를 만들기 위해선 코드 수준에서부터 정리되어야한다.

**SOLID 원칙의 목적**

- 변경에 유연
- 이해하기 쉽게
- 많은 소프트웨어 시스템에서 사용될 수 있는 컴포넌트 기반

# 7장 - SRP: 단일 책임 원칙

*하나의 모듈(클래스는) 하나의 책임만 가져야 한다.*

```
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.
```

이를 조금더 명확히 정의하면 다음과 같다.

```
하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
```

### 우발적 중복

![https://miro.medium.com/max/828/0*rYM9F-ekBa7O3DG0.jpg](https://miro.medium.com/max/828/0*rYM9F-ekBa7O3DG0.jpg)

Employee 클래스는 세가지 메서드 calculatePay(), reportHours(), save()를 가진다.

- calculatePay() 메서드는 회계팀에서 기능을 정의하고, CFO 보고를 위해 사용한다.
- reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위헤 사용한다.
- save() 메서드는 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.

여기서 만약 regularHours라는 메서드를 추가한다고 가정해보자. 해당 메서드는 calculatePay 메서드와 reportHours 메서드에 의존한다.

![https://velog.velcdn.com/images%2Fkjy991%2Fpost%2F9dba48fc-0a88-457a-b9bc-dd97f710c6c3%2Fimage.png](https://velog.velcdn.com/images%2Fkjy991%2Fpost%2F9dba48fc-0a88-457a-b9bc-dd97f710c6c3%2Fimage.png)

- CFO팀에서 reportHours 메서드를 수정해버렸다.
- 그러나 COO 팀에서는 수정된 방식을 사용하고 싶어하지 않는다.
- 하지만 개발자는 이을 모르고 그냥 변경한 뒤 적용해버렸다.
- 이로 인해 잘못된 데이터가 출력되고, 수백만 달러의 예산 손실이 일어났다.

### 병함

일반적으로 여러 액터가 의존하는 하나의 클래스(모듈)에 대해 소스코드를 여러 개발자들이 수정하다보면, 필연적으로 한 메서드나 클래스에 대해 충돌이 발생하게 된다.

- 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우
- 늘 그렇듯, 병합에는 위험이 뒤따른다.

### 병합 해결책

![https://miro.medium.com/max/1232/1*TU3rTyvNX76mXIr4VTzoqw.png](https://miro.medium.com/max/1232/1*TU3rTyvNX76mXIr4VTzoqw.png)

- 가장 기본적인 해결책은 메서드를 서로 다른 클래스로 옮기는 것
- 그러나 만약 클래스의 수가 많아진다면? 관리해야하는 수가 많아질수록 비효울적이다.
- 따라서 **파사드(Facade)** 패턴을 사용해 해결하는 방식이 있다.

![https://miro.medium.com/max/1400/0*mDtOoXtAmrM9vKSi.jpg](https://miro.medium.com/max/1400/0*mDtOoXtAmrM9vKSi.jpg)

또는 파사드에 핵심적인 구현내용은 기존 클래스에 그대로 유지하되, 덜 중요한 메서드들을 참조하는 형태로 바꿔서 쓸 수도 있다.



### 결론

- 왜 하나의 액터에 대해서만 책임져야 하는가?

**서로다른 액터가 처음에는 같은 유스케이스를 공유하더라도, 추후에 만약 어느 한 액터에서 유스케이스 변경사항이 생긴다면? 의존하는 또 다른 액터에서도 변경사항이 발생한다. 의도치 않은 변경사항 발생!**

**SRP는 메서드와 클래스 수준의 원칙이다**

# 8장 - OCP: 개방 폐쇄 원칙

*소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.*

```
소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
```

### 사고 실험



### 방향성 제어

- 컴포넌트 간의 관계를 명확히 하는 것도 중요하다. 일반적으로 컴포넌트간의 의존성은 단방향으로만 관계를 가지는 것이 가장 이상적이다.
- 가장 대표적인 MVC 패턴을 생각해보자

### 결론

- 왜 변경왜는 닫혀있어야 하는가?

**요구사항이 변경되어 새로운 기능을 만드는데 1000줄을 수정하는 것과, 0줄을 수정하는 것의 차이는 결국 OCP를 얼마나 준수하냐에 따라 달려있다.**

**OCP는 계층 수준의 원칙이다.**

# 9장 - LSP: 리스코프 치환 법칙

*프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.*

```
```

### 상속을 사용하도록 가이드하기

License 클래스가 다음과 같이 존재한다. 이 클래스는 calcFee()라는 메서드를 가지며, 두가지 하위 타입을 가지고 있다.

!(https://niqrid2020.pe.kr/wp-content/uploads/2021/02/%EC%BA%A1%EC%B2%981-1024x576.png)[https://niqrid2020.pe.kr/wp-content/uploads/2021/02/%EC%BA%A1%EC%B2%981-1024x576.png]

위 구현은 LSP를 잘 준수하고 있다. Billing 어플리케이션은 License가 어떤 하위타입을 사용하는지 알 필요가 없다.

### 정사각형/직사각형 문제 (LSP 위반 사례)

반대로 다음 정사각형/직사각형 클래스는 LSP를 위반한다.

### LSP 위배 사례

### 결론

- LSP를 준수하는 것은 아키텍처 관점에서 어떤 이득이 있는가?

**상위 클래스에서는 참조하는 클래스의 세부적인 구현 내용에 관심이 없다. **

**LSP는 메서드 클래스 수준의 설계원칙이다.**

# 질의응답

```text
지인:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
규훤:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진호:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
승직:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
천규:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
성준:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```
