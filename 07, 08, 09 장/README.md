# 진행 자료
# 개요
**SOLID 원칙이란?**

- 로바트 마틴이 기술한 5가지 객체지향프로그래밍의 5가지 법칙의 두문자어를 따온 것
- 좋은 소프트웨어는 깔끔한 코드(clean code)로부터 시작한다. 따라서, 좋은 아키텍처를 만들기 위해선 코드 수준에서부터 정리되어야한다.

**SOLID 원칙의 목적**

- 변경에 유연
- 이해하기 쉽게
- 많은 소프트웨어 시스템에서 사용될 수 있는 컴포넌트 기반

# 7장 - SRP: 단일 책임 원칙

*하나의 모듈(클래스는) 하나의 책임만 가져야 한다.*

```
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.
```

이를 조금더 명확히 정의하면 다음과 같다.

```
하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
```

### 우발적 중복

![https://miro.medium.com/max/828/0*rYM9F-ekBa7O3DG0.jpg](https://miro.medium.com/max/828/0*rYM9F-ekBa7O3DG0.jpg)

Employee 클래스는 세가지 메서드 calculatePay(), reportHours(), save()를 가진다.

- calculatePay() 메서드는 회계팀에서 기능을 정의하고, CFO 보고를 위해 사용한다.
- reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위헤 사용한다.
- save() 메서드는 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.

여기서 만약 regularHours라는 메서드를 추가한다고 가정해보자. 해당 메서드는 calculatePay 메서드와 reportHours 메서드에 의존한다.

![https://velog.velcdn.com/images%2Fkjy991%2Fpost%2F9dba48fc-0a88-457a-b9bc-dd97f710c6c3%2Fimage.png](https://velog.velcdn.com/images%2Fkjy991%2Fpost%2F9dba48fc-0a88-457a-b9bc-dd97f710c6c3%2Fimage.png)

- CFO팀에서 reportHours 메서드를 수정해버렸다.
- 그러나 COO 팀에서는 수정된 방식을 사용하고 싶어하지 않는다.
- 하지만 개발자는 이을 모르고 그냥 변경한 뒤 적용해버렸다.
- 이로 인해 잘못된 데이터가 출력되고, 수백만 달러의 예산 손실이 일어났다.

### 병함

일반적으로 여러 액터가 의존하는 하나의 클래스(모듈)에 대해 소스코드를 여러 개발자들이 수정하다보면, 필연적으로 한 메서드나 클래스에 대해 충돌이 발생하게 된다.

- 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우
- 늘 그렇듯, 병합에는 위험이 뒤따른다.

### 병합 해결책

![https://miro.medium.com/max/1232/1*TU3rTyvNX76mXIr4VTzoqw.png](https://miro.medium.com/max/1232/1*TU3rTyvNX76mXIr4VTzoqw.png)

- 가장 기본적인 해결책은 메서드를 서로 다른 클래스로 옮기는 것
- 그러나 만약 클래스의 수가 많아진다면? 관리해야하는 수가 많아질수록 비효울적이다.
- 따라서 **파사드(Facade)** 패턴을 사용해 해결하는 방식이 있다.

![https://miro.medium.com/max/1400/0*mDtOoXtAmrM9vKSi.jpg](https://miro.medium.com/max/1400/0*mDtOoXtAmrM9vKSi.jpg)

또는 파사드에 핵심적인 구현내용은 기존 클래스에 그대로 유지하되, 덜 중요한 메서드들을 참조하는 형태로 바꿔서 쓸 수도 있다.



### 결론

- 왜 하나의 액터에 대해서만 책임져야 하는가?

**서로다른 액터가 처음에는 같은 유스케이스를 공유하더라도, 추후에 만약 어느 한 액터에서 유스케이스 변경사항이 생긴다면? 의존하는 또 다른 액터에서도 변경사항이 발생한다. 의도치 않은 변경사항 발생!**

**SRP는 메서드와 클래스 수준의 원칙이다**

# 8장 - OCP: 개방 폐쇄 원칙

*소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.*

```
소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
```

### 사고 실험

재무제표를 웹 페이지로 보여주는 시스템이 있다고 가정해보자

![https://velog.velcdn.com/images/rudaks94/post/5541fa73-43bb-4884-ab72-158ca7e243cb/image.png](https://velog.velcdn.com/images/rudaks94/post/5541fa73-43bb-4884-ab72-158ca7e243cb/image.png)

- 다만, 흑백 프린터로 출력하게끔 만드는 기능도 추가된다고 가정해보자
- 새로운 코드를 작성하는데 있어, 기존 코드를 수정하지 않으려면?
- SRP(단일 책임 원칙)을 이용해 분리한다.

여기서 보고서 생성은 두 개의 책임으로 분리가 된다. 

이 처럼 책임을 분리하였다면, 둘 중 하나가 변경하더라도 다른 하나는 변경이 되지 않도록 조직해야한다.

이러한 처리 과정을 더 확장시켜 클래스 단위와 컴포넌트 단위로 생각해본다.

![https://t1.daumcdn.net/cfile/tistory/9935373A5E43875A02](https://t1.daumcdn.net/cfile/tistory/9935373A5E43875A02)

### 방향성 제어

![https://velog.velcdn.com/images/rudaks94/post/01934358-8ed7-4c71-9066-f0910d45f9cb/image.png](https://velog.velcdn.com/images/rudaks94/post/01934358-8ed7-4c71-9066-f0910d45f9cb/image.png)

- 컴포넌트 간의 관계를 명확히 하는 것도 중요하다. 일반적으로 컴포넌트간의 의존성은 단방향으로만 관계를 가지는 것이 가장 이상적이다.
- 가장 대표적인 MVC 패턴을 생각해보자

### 결론

- 왜 변경에 닫혀있어야 하는가?

**요구사항이 변경되어 새로운 기능을 만드는데 1000줄을 수정하는 것과, 0줄을 수정하는 것의 차이는 결국 OCP를 얼마나 준수하냐에 따라 달려있다.**

**OCP는 계층 수준의 원칙이다.**

# 9장 - LSP: 리스코프 치환 법칙

*프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.*

들어가기 앞서 하위타입의 정의를 먼저 살펴보자

```
여기에서 필요한 것은 다음과 같은 치환 원칙이다. S타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
```

### 상속을 사용하도록 가이드하기

License 클래스가 다음과 같이 존재한다. 이 클래스는 calcFee()라는 메서드를 가지며, 두가지 하위 타입을 가지고 있다.

![https://niqrid2020.pe.kr/wp-content/uploads/2021/02/%EC%BA%A1%EC%B2%981-1024x576.png](https://niqrid2020.pe.kr/wp-content/uploads/2021/02/%EC%BA%A1%EC%B2%981-1024x576.png)

위 구현은 LSP를 잘 준수하고 있다. Billing 어플리케이션은 License가 어떤 하위타입을 사용하는지 알 필요가 없다.

### 정사각형/직사각형 문제 (LSP 위반 사례)

반대로 다음 정사각형/직사각형 클래스는 LSP를 위반한다.

이 예제에서 Square는 Rectangle의 하위 타입으로는 적합하지 않다. 그러나 Square의 높이와 너비는 반드시 함께 변경된다. User는 Rectangle을 보고 있으므로 혼동이 생길 수 있다.

```java
Rectangle r = new Rectangle();
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```

만약 위의 코드를 실행하면 실패하게 된다.

여기서 LSP 위반을 막으려면 if 문을 추가하는 방식 따위로 Square인지 검사하는 매커니즘이 들어가야만 한다.

**그러나 이렇게 하면 타입치환이 불가능해진다.**

### LSP 위배 사례

구체적인 클래스 수준이 아닌 조금더 개략적인 수준인 REST API의 URI 설계로 가정해보자

택시 파견 서비스를 통합하는 어플리케이션을 만들고 있다.

이 때, 택시기사 밥의 택시 파견 URI는 다음과 같다.

```
purplecab.com/driver/Bob
```

그리고 PUT 방식으로 다음과 같이 호출한다.

```
PUT
purplecab.com/driver/Bob
            /pickupAddress/24 Maple ST.
            /pickUpTime/153
            /destination/ORD
```

### 결론

- LSP를 준수하는 것은 아키텍처 관점에서 어떤 이득이 있는가?

**상위 클래스에서는 참조하는 클래스의 세부적인 구현 내용에 관심이 없다.**

**LSP는 메서드와 클래스 그리고 아키텍처 수준의 설계원칙이다.**

# 질의응답

```text
지인:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진영: 모듈이랑 액터가 1대1 매칭되는 관계라는게 SRP라는거같은데 하나의 모듈을 여러액터가 공유하게 되는경우는 아예 없을까요?

대답: 어떤 답변을 원하는 건지 잘 모르겠네요. SRP 위반 사례를 이야기 하는 것인가요...? 음 당장 생각나는 건 횡단관심사에 속하는 모듈은 여러 액터가 보통 공유하는 것 같습니다. (로깅, 보안, 유틸성 함수 등)
```

```text
규훤:
68p에서 `calculatePay`와 `reportHours`에서 공통으로 함수 `**regularHours**`를 호출하면, 
한 함수의 용도 변경으로 인해 `**regularHours**`가 수정되었을 때 다른 한 함수도 의도치 않게 변경의 영향을 받을 수 있으므로, 
70p에서 이에 대한 해결책으로 각 함수를 클래스로 나누는 방법을 제시했습니다. 

만약 같은 로직(`regularHours`)을 많은 곳에서 사용하면, 클래스로 나눴을 때 중복 코드가 그만큼 생기는 셈인데,
나중에 정말 해당 로직에 변경이 생기면 중복 코드를 모두 고쳐줘야하는 수고가 들 것 같습니다.
완벽한 분리를 하는 것이 중복 코드를 유발하지는 않을까요?

대답: 비록 같은 중복 이더라도, 결과적으로 추후에 해당 클래스를 의존하는 액터가 의도치 않게 영향을 받는 실수를 최소화하기 위해 분리한다고 책에서는 이야기합니다. 아무래도 SRP를 쓰다보면 초기에는 필연적으로 중복이 생길 수 밖에 없을 거라는 생각이 듭니다. 하지만 실제 책의 예시 같은 사례를 생각해보면 중복이 발생하더라도 책임을 분리하는 건 필요하지 않나 싶습니다. 왜냐하면 실제로 비즈니스 로직이나 요구사항 따위가 어떤 액터에서 변경사항이 생기는 걸 이미 가정하고 있기 때문에 처음에는 중복 코드가 발생한다 하더라도 결국에는 중복적인 요소는 없어지지 않을까..? 라는 의견입니다.
```

```text
진호: 7장 - SRP를 지키려면 액터에 따른 변경 가능성이 조금이라도 있는 코드는 중복됨을 감수하면서 모두 따로 작성해야 할까요? 변경 가능성을 예측할 수 있는 방법은 무엇이며, 최대한 중복을 피할수 있는 방법이 있을까요? 예를 들어 regularHours() 메서드를 Template Method 패턴으로 만들면 어떨까요?
대답: 중복을 감수하면서 따로 작성하는 것에 관한 것은 규훤님의 답변을 참조하시면 될 것 같습니다. 변경 가능성을 예측하는 방법...은 처음 설계 할 때부터 액터가 분리되어 있는가?를 유심히 살펴봐야 하지 않을까요? 저도 중복의 대안으로 템플릿메서드를 생각했는데, 좋은 방법이라고 생각합니다. 아니면 비슷한 데코레이터 패턴을 적용하는 방법도 있을 것 같네요.
```

```text
승직:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
천규:
9장 - 책에서 LSP 위배 사례로 소개된 택시 파견 서비스가 어떻게 LSP를 위반하는지 정확하게 이해가 되지 않습니다.
ACME사가 destination 필드를 변경함으로써 다른 회사 프로그램에 ACME의 인터페이스를 사용할 수 없게 된 것이 LSP가 깨졌다는 것인가요?
만약 그렇다면 앞 부분에서는 "하위 타입의 객체가 상위 객체를 대체할 수 있도록 하는 것"이 LSP 원칙이라고 하였는데,
해당 사례는 마치 모든 회사의 인터페이스가 하위/상위의 구분 없이 상호 치환(대체)이 가능한 듯 하여 적절한 예시인지 의문이 듭니다.

대답: LSP는 메서드와 클래스 그리고 코드 수준의 인터페이스에서만 적용가능한 법칙이라고 보기는 어렵습니다. 조금 더 추상화된 넓은 범위(아키텍처) 수준에서도 LSP를 적용할 수 있다고 이야기하는데, 이 예시가 바로 ACME사의 택시 파견서비스라고 볼 수 있습니다. 예를들어 상위 클래스(A)에서 참조하는 어떤 클래스(B)가 구체적으로 어떤 타입을 사용하는지에는 관심이 없습니다. 그저 A는 B를 가져다쓰기만 하면 그만입니다. 이는 정보은닉의 개념과도 유사한데, 이것이 바로 LSP의 핵심 개념입니다. 더 나아가서 아키텍처 수준에서 생각해보기 위해 택시파견 서비스를 생각해보면, 택시 파견 서비스의 API를 호출하는 데 있어 어떤 회사의 택시를 호출하는지는 중요하지 않습니다. 그냥 명세된 하나의 API 엔드포인트에 적절한 파라미터를 넘겨주기만 하면 그만이죠. 그렇기에 다른 업체의 택시를 부르기 위해 별도의 예외처리를 해주는 것은 LSP를 위반한다고 봐야합니다. 

 질문으로 다시 돌아와 답하자면 결론적으로 모든 회사의 인터페이스가 하위/상위 구분 없이 치환 가능하다고 볼 수는 없습니다. 왜냐하면 ACME의 사의 API와 기존회사의 API 정보는 서로 다른 인터페이스를 지니고 있죠(destination이 아니라 dest를 필드로 쓰는 것과 같이). 그러므로 책에서는 이런 예외처리를 추가적으로 더 하기 위해 설정용 데이터베이스를 추가한다는 극단적인 예시까지 보여주고 있는거죠. 결국엔 하나의 인터페이스로 여러 로직을 처리하는 형태가 아니라 여러개의 인터페이스가 생기고 각각 따로 처리하는 LSP를 완전히 위배하는 사례라고 봐야할 것입니다.
```

```text
성준:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```
