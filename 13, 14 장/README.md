# 진행 자료

# 컴포넌트 응집도

- 어떤 클래스를 어느 컴포넌트에 포함시켜야할까?
- 이는 중요한 결정이므로 제대로 된 소프트웨어 엔지니어링 원칙의 도움을 받아야한다.
- 하지만 우리는 임시방편적으로 결정을 내려왔다.

<br/>

- 이 장에서는 컴포넌트 응집도와 관련된 세 가지 원칙을 논의한다.
1. REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
2. CCP: 공통 폐쇄 원칙 (Common Closure Principle)
3. CRP: 공통 재사용 원칙 (Common Reuse Principle)

## REP: 재사용/릴리스 등가 원칙

| 재사용 단위는 릴리스 단위와 같다.

- 지난 십 년은 모듈 관리 도구가 우후죽순으로 등장한 시기였다.
- 이 기간에 재사용 가능한 컴포넌트나 라이브러리가 엄청나게 많이 만들어졌기 때문에, 이 같은 도구들은 점점 중요해졌다.

<br/>

- 돌이켜보면 REP는 너무 당연해 보인다.
- 컴포넌트가 추적 관리되지 않거나, 릴리스 번호가 부여되지 않는다면 재사용하고 싶어도 할 수 없고, 하지도 않을 것이다.
- 즉 릴리스에 충분한 정보가 있어야 개발자가 새 릴리스를 통합할지, 한다면 언제할지 결정할 수 있다.

<br/>

- 이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.
- 즉 컴포넌트를 구성하는 모든 모듈을 서로 공유하는 중요한 테마나 목적이 있어야한다.

<br/>

- 이 사실은 물론 너무 당연하다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 
1. 버전 번호가 같아야 하며 
2. 동일한 릴리스로 추적 관리되고
3. 동일한 문서에 포함되어야 한다
- 는 사실은 컴포넌트 제작자 입장이나 사용자 입장에서도 이치에 맞는 얘기다

<br/>

- 하지만 이 원칙의 조언은 약하다.
- 구체적인 해결 방법을 제시해주지는 못하기 때문이다.
- 이 원칙의 약점은 다음에 다룰 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있다.

## CCP: 공통 폐쇄 원칙 

| 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

- 이 원칙은 SRP를 컴포넌트 관점에서 다시 쓴 것이다.
- SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, CCP에서도 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다고 말한다.

<br/>

- 대다수의 어플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
- 어플리케이션 코드가 반드시 변경되어야한다면, 변경 사항이 여러 컴포넌트에 분산되어 발생하는 것보다, 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.
- 변경된 컴포넌트만 재배포하면 되기 때문이다.

<br/>

- CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.
- 이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.

<br/>

- 이 원칙은 OCP와도 밀접하게 관련되어 있다.
- OCP에서 말하는 폐쇄와 CCP에서 말하는 폐쇄와 뜻이 같다. 즉 변경에 닫혀있어야한다.
- 하지만 100% 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄해야 한다.
- 따라서 변경이 생겼을 때, 그 변경으로 영향을 받는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.

<br/>

## CRP: 공통 재사용 원칙

| 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

- CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다.
- 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용 하는 경우가 많다.
- 간단한 사례로 컨테이너 클래스와 해당 클래스의 이터레이터 클래스를 들 수 있다.
- 이 클래스들은 강하게 결합되어 있기 때문에, 이 클래스들은 반드시 동일한 컴포넌트에 위치해야 한다.

<br/>

- CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.
- 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생긴다.
- 어쩌면 단 하나의 클래스만 사용하는 상황일 수도 있다. 하지만 그렇다고 해서 의존성은 조금도 약해지지 않는다.
- 이 같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다.
- 따라서 의존해야 하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.

<br/>

- 바꿔 말하면, 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다.
- 즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다.
- 따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다.

## 컴포넌트 응집도에 대한 균형 다이어 그램

- 응집도에 관한 세 원칙이 서로 상충된다는 것은 눈치챘을 것이다.
- REP와 CCP는 포함 원칙이다.
- 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.
- CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만든다.

![](https://velog.velcdn.com/images/eplue/post/38cf3965-ecb6-415c-9b52-21568de1f674/image.png)

- 오로지 REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다.
- 반대로 CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.
- 뛰어난 아키텍트라면 이 균형 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 한다.
- 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편이며, 이 때는 오직 재사용성만 희생하면 된다.
- 점차 프로젝트가 성숙해지면서, 프로젝트는 점차 왼쪽으로 이동해간다.

# 컴포넌트 결합

- 지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.
- 이 장에서 만찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다.
- 컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.

## ADP: 의존성 비순환 원칙 (Acyclic Dependencies Principle)

| 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

- 하루 종일 일해서 무언가를 작동하게 만들고, 다음날 출근해보면 돌아가지 않는 경험을 해본적이 있지 않은가?
- 왜냐하면 누군가 당신이 의존하고 있던 무언가를 수정했기 때문이다.
- 저자는 이런 현상을 '숙취 증후군'이라고 부른다.

<br/>

- 숙취 증후군은 소수의 개발자로 구성된 상대적으로 작은 프로젝트에서는 이 증후군이 그다지 큰 문제가 되지 않는다.
- 하지만 프로젝트와 개발팀의 규모가 커지면 숙취는 지독한 악몽이 될 수도 있다.
- 지난 수십년간 이 문제의 해결책으로 두 가지 방법이 발전되어 왔다.
- 첫 번째 해결책은 '주 단위 빌드'이며
- 두 번째 해결책은 '의존성 비순환 원칙'이다

### 주 단위 빌드 (Weekly Build)

- 주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다.
- 주 단위 빌드를 하는 방법은 다음과 같다.
1. 모든 개발자들은 4일 동안 서로 신경쓰지 않고 개발한다. 즉 어떻게 통합할지 걱정하지 않는다.
2. 그런 후 4일이 지나면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
- 이 접근법은 5일 중 4일동안 개발자를 고립된 세계에서 살 수 있게 보장해준다는 아주 멋진 장점을 가진다.
- 물론 단점은 금요일에 통합과 관련된 막대한 업보를 치러야 한다는 사실이다.

<br/>

- 안타깝게도 프로젝트가 커지면 프로젝트 통합은 금요일 하루 만에 끝마치는게 불가능해진다.
- 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.
- 이 같은 흐름은 마침내 위기를 초래한다.
- 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다.

### 순환 의존성 제거하기

- 이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
- 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
- 해당 개발자는 컴포넌트를 동작하게 만든 후 다른 개발자가 사용할 수 있도록 컴포넌트를 릴리스한다.
- 컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결정해야 한다.
- 적용하지 않기로 했다면 그냥 과거 버전의 릴리스를 계속 사용한다.
- 따라서 어떤 팀도 다른 팀에 의해 좌우되지 않는다.
- 각 팀은 새롭게 릴리스된 특정 컴포넌트에 맞춰 수정할 시기를 스스로 결정할 수 있다.
- 즉 통합은 작고 점진적으로 이루어진다.

<br/>

- 이 방식은 단순하며 합리적이어서 널리 사용되는 방식이다.
- 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.
- 의존성 구조에 순환이 있어서는 안 된다.

![](https://sungjk.github.io/images/2019/10/26/14_1.png)

- 위 다이어그램에서는 컴포넌트를 조립하여 어플리케이션을 만드는 다소 전형적인 구조를 볼 수 있다.
- 중요한 점은 컴포넌트 간의 의존성 구조다.
- 한 가지 더 주목할 점이 있다. 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아 갈 수 없다는 것이다.
- 즉 비순환 방향 그래프다.

<br/>

- 이제 Presenters를 담당하는 팀에서 이 컴포넌트의 새로운 릴리스를 만들면 무슨 일이 벌어질지를 생각해보자.
- 이 릴리스에 영향받는 팀은 의존성 화살표를 거꾸로 따라가면 쉽게 찾을 수 있다.
- 즉 View, Main 컴포넌트 둘 다 영향을 받는다.
- 이 두 컴포넌트를 작업 중인 개발자라면, Presenter의 새로운 릴리스와 자신의 작업물을 언제 통합할지를 반드시 결정해야 한다.
- 또한 Main은 새로 릴리스되더라도 시스템에서 이로 인해 영향받는 컴포넌트가 전혀 없다는 사실에 주목하자.
- 나머지 컴포넌트는 Main에 대해 알지 못하므로 Main이 변경되더라도 전혀 개의치 않는다.

<br/>

- Presenters 컴포넌트를 만드는 개발자가 이 컴포넌트를 테스트하고자 한다면, 단순히 현재 사용 중인 버전의 Interactors와 Entities를 이용해서 Presenters 자체 버전을 빌드하면 그만이다.
- 이 빌드 과정에서 시스템의 나머지 컴포넌트는 전혀 관련이 없다.
- 즉 테스트를 구성할 때 적은 노력이 든다는 것이며, 고려해야할 변수도 상대적으로 적다는 뜻이기도 하다.

<br/>

- 시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.
- 먼저 Entities 컴포넌트를 컴파일하고, 테스트하고, 릴리스한다.
- 그리고 나서 Database와 Interactors에 대해서도 동일한 과정을 거친다.
- Main은 마지막에 처리한다.
- 이 처럼 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다.

### 순환이 컴포넌트 의존성 그래프에 미치는 영향

- 새로운 요구사항이 발생해서 Entities에 포함된 클래스 하나가 Authorizer에 포함된 클래스 하나를 사용하도록 변경할 수밖에 없다고 가정해보자.
- 예를 들어 Entities의 User 클래스가 Authorizer의 Permissions 클래스를 사용한다고 해보자.
- 그럼 아래 그림과 같이 순환 의존성이 발생한다.

![](https://uchanlee.dev/static/6005b83720c2dd84929d83b923528691/0a47e/image-14.2.png)

- 이 순환은 즉각적인 문제를 일으킨다.
- 예를 들어, Database 컴포넌트를 만드는 개발자는 컴포넌트를 릴리스 하려면 Entities 컴포넌트와 반드시 호환되어야 한다는 사실을 알고있다.
- 하지만 Entities 컴포넌트에는 순환이 있으므로, Database 컴포넌트 또한 Authorizer와도 호환되어야한다.
- 그런데 Authorizer는 Interacto에 의존한다.
- 즉 Entities, Authorizer, Interactors는 사실상 하나의 거대한 컴포넌트가 되어버린다.
- 즉 이 컴포넌트들 중 어느 것을 개발하더라도 '숙취 증후군'에 떠는 경험을 하게 될 거라는 의미다.

<br/>

- 하지만 이는 겪게 될 문제 중 일부일 뿐이다.
- Entities 컴포넌트를 테스트할 때 무슨일이 벌어질지를 생각해보라.
- 유감스럽게도 Authorizer와 Interactors까지도 반드시 빌드하고 통합해야 한다.
- 뿐만 아니라 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.
- 사실 순환이 생기면 올바른 순서라는게 없을 수 있다.

### 순환 끊기

- 컴포넌트 사이의 순환을 끊고 의존성을 다시 비순환 방향 그래프로 원상복구하는 일은 언제라도 가능하다.
- 이를 위한 주요 메커니즘 두 가지를 살펴보자.

<br/>

1. DIP를 적용한다.

![](https://uchanlee.dev/static/7f579cd6cb89c723fb56ee99dd4f20e5/0a47e/image-14.3.png)

- 위 그림처럼 User가 필요로 하는 메서드를 제공하는 인터페이스를 생성한다.
- 그리고 이 인터페이스는 Entities에 위치시키고, Authorizer에서는 이 인터페이스를 상속받는다.
- 이렇게 하면 Entities와 Authorizer 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.

<br/>

2. Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다.

![](https://uchanlee.dev/static/d6ca8fdc9c1a119dc7da195141d491d3/0a47e/image-14.1.png)

- 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 옮긴다.

### 흐트러짐 (Jitters)

- 두 번째 해결책에서 시사하는 바는 요구사항이 변경되면서 컴포넌트 구조도 변경될 수 있다는 사실이다.
- 실제로 어플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다.
- 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다.

## 하향식 (top-down) 설계

- 지금까지의 논의로 우리는 피할 수 없는 결론에 다다르게 된다.
- 즉, 컴포넌트 구조는 하향식으로 설계될 수 없다.
- 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.

<br/>

- 컴포넌트 의존성 다이어그램은 어플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.
- 오히려 컴포넌트 의존성 다이어그램은 어플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다.
- 바로 이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.
- 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요 없기 때문이다.

<br/>

- 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.
- 우리는 변덕스러운 이유로 자주 변경되는 컴포넌트로 인해, 그렇지 않았다면 안정적이었을 컴포넌트가 영향받는 일을 원치 않는다.
- 결국 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.

## SDP: 안정된 의존성 원칙 (Stable Dependencies Principle)

| 안정성의 방향으로(더 안정된 쪽에) 의존하라.

- 설계는 결코 정적일 수 없다. 
- CCP를 준수함으로써, 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다.
- 우리는 변동성을 지니도록 설계한 컴포넌트는 언젠가 변경되리라고 예상한다.
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
- 한 번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.

<br/>

- 이는 소프트웨어가 가진 괴팍함이다.
- 즉, 당신이 모듈을 만들 때는 변경하기 쉽도록 설계했지만, 이 모듈에 누군가가 의존성을 매달아 버리면 당신의 모듈도 변경하기 어려워진다.
- SDP를 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

### 안정성

- 안정성이란 무슨 뜻인가?
- 동전을 옆면으로 세워보라. 이 상태에서 동전은 안정적인가라고 물어보면 아니요라고 말할 것이다.
- 하지만 동전을 건드리지 않는다면 동전은 이 상태로 꽤 오랫동안 서 있을 수 있다.
- 따라서 안정성은 변화가 살생하는 빈도와는 직접적인 관련이 없다.
- 동전의 경우 옆으로 쓰러지는 등 상태가 변하지는 않았지만, 이 상태를 안정적이라고 보기는 어렵다.

<br/>

- 무언가 안정적이라는 말을 웹스터 사전에서는 '쉽게 움직이지 않는'이라고 정의한다.
- 옆면으로 선 동전이 안정적이지 않은 이유는 그다지 힘을 쓰지 않고도 넘어뜨릴 수 있기 때문이다.
- 반면 탁자는 상당히 안정적인데, 탁자를 뒤집으려면 상당한 수고를 감수해야 하기 때문이다.

<br/>

- 이러한 사실과 소프트웨어는 어떤 관련이 있을까?
- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 많은 요인으로
    - 컴포넌트의 크기
    - 컴포넌트의 복잡도
    - 컴포넌트의 간결함
- 등을 예로 들 수 있다.
- 여기에서 이러한 요인들은 모두 무시하고, 좀 더 특이한 요인에 주목하려고 한다.
- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.
- 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.

<br/>

![](https://sungjk.github.io/images/2019/10/26/14_5.png)

- 위 그림의 X는 안정된 컴포넌트다.
- 세 컴포넌트가 X에 의존하며, 따라서 X 컴포넌트는 변경하지 말아야 할 이유가 세 가지나 되기 때문이다.
- 이 경우 X는 세 컴포넌트를 책임진다라고 말한다.
- 반대로 X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다.
- 이 경우 X는 독립적이다라고 말한다.

<br/>

![](https://uchanlee.dev/static/edce24d78ce38e44183288b4dad71ec0/0a47e/image-14.6.png)

- 위 그림의 Y는 상당히 불안정한 컴포넌트다.
- 어떤 컴포넌트도 Y에 의존하지 않으므로 Y는 책임성이 없다고 말할 수 있다.
- 또한 Y는 세 개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 세 가지다.
- 이 경우 Y는 의존적이라고 말한다.

### 안정성 지표

- 어떻게 하면 컴포넌트 안정성을 측정할 수 있을까?
- 컴포넌트로 들어오고 나오는 의존성의 개수를 세어 보는 방법이 있을 수 있다.
- 이 숫자를 통해 컴포넌트가 위치상 어느 정도의 안정성을 가지는지 계산할 수 있다.

<br/>

- _Fan-in_: 안으로 들어오는 의존성.
    - 이 지표는 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타낸다.
- _Fan-out_: 바깥으로 나가는 의존성.
    - 이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타낸다.
- _I_(불안정성): _I_ = _Fan-out_ ÷ (_Fan-in_ + _Fan-out_)
    - 이 지표는 [0, 1] 범위의 값을 갖는다.
    - _I_ = 0이면 최고로 안정된 컴포넌트라는 뜻이다.
    - _I_ = 1이면 최고로 불안정한 컴포넌트라는 뜻이다.
- _Fan-in_ 과 _Fan-out_ 지표는 특정 컴포넌트 내부의 클래스에 의존하는, 컴포넌트 외부에 위치한 클래스이 개수를 세어서 계산할 수 있다.

![](https://user-images.githubusercontent.com/20153890/122218563-89d3e800-cee9-11eb-9d8c-0c64052fd0a9.png)

- Cc 컴포넌트의 안정성을 계산해야 한다고 해보자.
- 보다시피 Cc 내부의 클래스에 의존하며 Cc 외부에 있는 클래스는 세 개다.
- 따라서 _Fan-in_ = 3이다.
- 또한 Cc 내부의 클래스가 의존하는 Cc 외부에 위차한 클래스는 한 개다.
- 따라서 _Fan-out_ = 1이고, _I_ = 1/4 이다.

<br/>

- _I_ 값이 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 다른 컴포넌트에 의존한다는 뜻이다.
    - 이러한 상태는 컴포넌트가 가질 수 있는 최고로 불안정한 상태다.
    - 이 컴포넌트는 책임성이 없으며 의존적이다.
    - 자신에게 의존하는 컴포넌트가 없으므로, 이 컴포넌트는 변경하지 말아야 할 이유가 없다.
    - 하지만 다른 컴포넌트에 의존하고 있으므로 언젠가 해당 컴포넌트를 변경해야할 이유가 있다는 뜻이다.
- 반대로 _I_ 값이 0이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만, 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다는 뜻이다.
    - 이러한 컴포넌트는 다른 컴포넌트를 책임지며 또 독립적이다.
    - 이러한 상태는 컴포넌트가 가질 수 잇는 최고로 안정된 상태다.
    - 자신에게 의존하는 컴포넌트가 있으므로 해당 컴포넌트는 변경하기가 어렵다.
    - 하지만 해당 컴포넌트를 변경하도록 강제하는 의존성은 갖지 않는다.

<br/>

- SDP에서 컴포넌트의 _I_ 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 _I_ 보다 커야 한다고 말한다.
- 즉 의존성 방향으로 갈수록 _I_ 지표 값이 감소해야한다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

- 모든 컴포넌트가 최고록 안정적인 시스템이라면 변경이 불가능하고 이는 바람직한 상황이 아니다.
- 사실 우리가 컴포넌트 구조를 설계할 때 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상태다.

![](https://uchanlee.dev/static/dc69bd12c60636285300481d41f78c93/0a47e/image-14.8.png)

- 위 다이어그램은 세 컴포넌트고 구성된 시스템이 가질 수 있는 가장 이상적인 구조다.
- 위쪽에는 변경 가능한 컴포넌트가 보이고, 아래의 안정된 컴포넌트에 의존한다.
- 다이어그램에서 불안정한 컴포넌트를 관례적으로 위쪽에 두는데, 이 관례를 따르면 상당히 유용하다.
- 위로 향하는 화살표가 있으면 SDP를 위배하는 (그리고 나중에 보겠지만 ADP도 위반하는) 상태가 되기 때문이다.

![](https://miro.medium.com/max/1400/1*ci7PeVlyEKFeP_HNaGKSWw.png)

- 위 다이어그램에서는 SDP가 어떻게 위배될 수 있는지를 보여준다.
- Flexible은 변경하기 쉽도록 설계한 컴포넌트다. 또한 Flexible은 불안정한 상태이기를 바란다.
- 하지만 Stable 컴포넌트에서 작업하던 개발자가 Flexible에 의존성을 걸게 되었다.
- 이로 인해 SDP를 위배하는데, Stable의 _I_ 지표는 Flexibel의 _I_ 지표보다는 더 작기 때문이다.
- 결국 Flexble은 변경하기가 어렵게 되었다.

<br/>

- 이 문제를 해결하려면 Stable의 Flexible에 대한 의존성을 어떤 식으로든 끊어야한다.

![](https://blog.kakaocdn.net/dn/bvRbbT/btrlQ1Zj89W/hs9dKDpl7zKmpFHk0yRk31/img.png)

- Stable 내부의 클래스 U가 Flexible 내부의 클래스 C를 사용한다고 가정해보자.
- DIP를 도입하면 이 문제를 해결할 수 있다.
- 먼저 US라는 인터페이스를 생성한 후 UServer 컴포넌트에 넣는다.
- 이때 US 인터페이스에는 U가 사용하는 모든 메소드가 반드시 선언되어 있어야한다.

![](https://blog.kakaocdn.net/dn/ddCBVJ/btrlV1XPnuT/Tbge4pPzJ3TZ9JYP2JLU8K/img.png)

- 그리고 위 그림처럼 C가 해당 인터페이스를 구현하도록 만든다.
- 이를 통해 Stable의 Flexible에 대한 의존성을 끊을 수 있고, 두 컴포넌트는 모두 UServe에 의존하도록 강제한다.
- UServe는 매우 안정된 상태이며, Flexible은 자신에게 맞는 불안정성을 그대로 유지할 수 있다.
- 이제 모든 의존성은 _I_ 가 감소하는 방향으로 향한다.

### 추상 컴포넌트

- 오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 방식이 이상해 보일 수도 있다.
- 자바나 C# 같은 정적 타입 언어를 사용할 때 이 방식은 상당히 흔할 뿐만 아니라, 꼭 필요한 전략으로 알려져있다.
- 이러한 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.

## SAP: 안정된 추상화 원칙 (Stable Abstractions Principle)

| 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

### 고수준 정책을 어디에 위치시켜야 하는가?

- 시스템에는 자주 변경해서는 절대로 안 되는 소프트웨어도 있다.
- 따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(_I_ = 0)에 위치해야 한다.
- 불안정한 컴포넌트 (_I_ = 1)는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다.

<br/>

- 하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기가 어려워진다.
- 이로 인해 시스템 전체 아키텍처가 유연성을 잃는다.
- 컴포넌트가 최고 안정된 상태이면서도(_I_ = 0) 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?
- 해답은 OCP에서 찾을 수 있다.
- OCP에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있다.
- 추상 클래스가 이 원칙을 준수한다.

### 안정된 추상화 원칙

- 안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.
- 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다.
- 다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.
- 따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야한다.

<br/>

- SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 된다.
- 실제로 SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하고
- SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문이다.
- 따라서 의존성은 추상화의 방향으로 향하게 된다.

### 추상화 정도 측정하기

- A 지표는 컴포넌트의 추상화 정도를 측정한 값이다.
- 이 값은 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값이다.
    - _Nc_ : 컴포넌트의 클래스 개수
    - _Na_ : 컴포넌트의 추상 클래스와 인터페이스 개수
    - _A_ : 추상화 정동. _A_ = _Na_ ÷ _Nc_
- A 지표는 0과 1사이의 값을 가진다.
- A가 0이면 컴포넌트에 추상 클래스가 하나도 없다는 뜻이다.
- A가 1이면 컴포넌트는 오로지 추상 클래스만을 포함한다는 뜻이다.

### 주계열

- 이제 안정성과 추상화 정도 사이의 관계를 정의해야 할 때가 왔다.

![](https://blog.kakaocdn.net/dn/bLDVwO/btrlY48SjUq/sLT5vvQlHQj2EmI14I21sk/img.png)

- 이 그래프에 두 종류의 유의미한 컴포넌트를 표시해 보자.
- 최고로 안정적이며, 추상화된 컴포넌트는 좌측 상단인 (0, 1)에 위치하는 것을 확인할 수 있다.
- 최고로 불안쩡하며, 구체화된 컴포넌트는 우측 하단인 (1, 0)에 위치한다.

<br/>

- 모든 컴포넌트가 이 두 지점에 위치하는 것은 아닌데, 대체로 컴포넌트는 추상화와 안정화의 정도가 다양하기 때문이다.
- 모든 컴포넌트가 (0, 1) 또는 (1, 0)에 위치해야 한다는 규칙을 강요할 수는 없다.

![](https://user-images.githubusercontent.com/25674959/114589383-93ab5600-9cc2-11eb-91d8-b13924a5e583.png)

### 고통의 구역

- (0,0) 주변 구역에 위치한 컴포넌트를 살펴보자.
- 이 컴포넌트는 매우 안정적이며 구체적이다.
- 이러한 컴포넌트는 추상적이지 않아 확장할 수 없고, 안정적이므로 변경하기도 어렵다.
- (0,0)은 배제해야 할 구역이며, 고통의 구역이라고 부른다.
- 변동성이 없는 컴포넌트는 이 구역에 위치했더라도 해롭지않다.
- 문제가 되는 경우는 변동성이 큰 컴포넌트가 위치하는 경우다.

### 쓸모없는 구역

- (1, 1) 주변의 컴포넌트를 생각해보자.
- 여기에 위치한 컴포넌트는 최고로 추상적이만, 누구도 그 컴포넌트에 의존하지 않기 때문이다.
- 이러한 컴포넌트는 쓸모가 없다.
- 따라서 이 영역은 쓸모없는 구역이라고 부른다.

### 배제 구역 벗어나기

- 따라서 변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 멀리 떨어뜨려야 한다.
- 최대한 멀리 떨어진 점의 궤적은 (1,0)과 (0,1)을 잇는 선분이고 이를 주계열이라고 부른다.
- 주계열에 위치한 컴포넌트는 자신의 안정성에 비해 '너무 추상적'이지도 않고
- 추상화 정도에 비해 '너무 불안정'하지도 않다.
- 컴포넌트들은 주계열 바로 위에 또는 가깝게 위치할 때가 가장 이상적이다.

### 주계열과의 거리

- 여기에서 세 번째 지표가 도출된다.
- 컴포넌트가 주계열로부터 얼마나 멀리 떨어져 있는지 측정하는 지표를 만들어볼 수 있다.

<br/>

- D: 거리. D = |A + I - 1|.
- 이 지표의 유효범위는 [0, 1]이다.
- D가 0이면 컴포넌트가 주계열 바로 위에 위치한다는 뜻이며
- D가 1이면 컴포넌트가 주계열로부터 가장 멀리 위치한다는 뜻이다.

<br/>

- 이 지표를 계산하면 컴포넌트가 주계열에 대체로 일치하도록 설계되었는지를 분석할 수 있다.
- D 지표를 계산하고 D갑이 0에 가깝지 않는 컴포넌트가 있다면 해당 컴포넌트는 재검토한 후 재구성할 수 있다.
- 또한 설계를 통계적으로 분석하는 일 또한 가능해진다.
- 모든 컴포넌트에 대해 D 지표의 평균과 분산을 구한다.
- 분산을 통해 다른 컴포넌트에 비해 '극히 예외적인' 컴포넌트를 식별할 수 있기 때문이다.

![](https://user-images.githubusercontent.com/25674959/114594386-2a2e4600-9cc8-11eb-965f-04422e4ab534.png)

- 위 그림에서 보이듯이 대부분의 컴포넌트는 주계열을 따라 위치하지만 일부 컴포넌트는 표준편차가 1(Z = 1)인 영역을 벗어나 있다.
- 이 처럼 이상한 컴포넌트는 면밀히 검토해볼 가치가 있다.

---

# 질의응답


```text
진영: REP에서 재사용 단위 == 릴리즈 단위라고 하는데 결국 컴포넌트는 내부구성 요소들이 같이 릴리즈(업데이트)된다는 의미로 받아들여 집니다.
그렇게 보면 CCP역시 컴포넌트 상에서의 SRP라고 동일한 시점에 동일한 이유로 변경되는 애들 끼리  묶으라는게 같이 업데이트 되는 구성요소끼리 묶으라고 받아들여집니다.
그렇다면, REP,CCP가 거의 유사해보이는데.. 두 원칙을 따로 적용할수는 없을까요? 
따로 적용할 수 있다면 REP는 지켰지만 CCP를 못지켰다던가, 혹은 그 반대인 경우에 대한 예시를 하나 알려주세요~

대답: REP, CCP 모두 컴포넌트를 커지게 하는 포함 원칙이라서 유사도가 높습니다.
하지만 유사도가 높을 뿐 다른 점은 명확하지는 않더라도 있다고 상각하는데요.
일단 먼저 간단하게 말하자면 REP가 CCP보다 포함하려는 성격이 덜한 것 같습니다.

예를 들면 A 컴포넌트 안에 재사용 가능한 b 클래스와 b 클래스를 사용하는 c 클래스가 있다고 해보겠습니다.
REP에 따르면 b 클래스는 재사용 단위와 릴리스 단위가 같습니다. 또한 c 클래스의 릴리스 단위는 신경도 쓰지 않죠.
하지만 CCP에 따르면 c 클래스는 b 클래스의 릴리스 단위를 따라갈 수 밖에 없죠.
즉 두 원칙의 강제성이 좀 다른 것이 차이점이라고 생각합니다.

물론 이 얘기를 듣고 애초에 b와 c를 같은 컴포넌트에 두지말고 따로 뒀어야 하는것 아니냐 라고 하실 수도 있을 것 같은데요
맞는 얘기입니다.
하지만 여기서도 CCP에 의하면 c 가 b를 사용하기 때문에 같은 컴포넌트에 포함하려고 하는 성질이 커지게 됩니다.
반면 REP만 고려해봤을 때는 두 클래스를 분리해도 아무런 문제가 없는 것을 확인 할 수 있죠. 

이러한 차이가 REP와 CCP의 차이점인 것 같습니다.
REP만 적용하는 것은 가능하지만 CCP를 적용하면서 REP를 적용하지 않는 것은 불가능할 것 같다... 라고 생각되네요.

```

```text
규훤:
119p에서 ADP를 설명할 때 배포를 한 쪽 방향으로만 하고
순차적으로 전 단계의 배포를 적용하면서 다음 단계로 배포해야 한다고 나와있습니다.

이렇게 순차적으로 개발을 해야하는 구조가 되면, 신규 기능 하나를 개발하기 위해서
마지막 단계(Application)는 이전 단계들이 순차적으로 모두 해당 기능을 추가할 때까지 기다려야 하고,
그제서야 사용자에게 배포가 가능해지는데, 기능 추가의 주기가 너무 오래 걸리진 않을까요?

p.s. 질문을 남기고 생각났는데, 애초에 배포 주기를 이렇게 타이트하게 안잡는게 정상인가..? 싶기도 하네요ㅎㅎ

대답: 음 제 생각에는 해당 내용을 조금 잘못 이해하신거 아닌가 싶습니다.
책에서는 각 컴포넌트가 릴리스하는 것이 각 컴포넌트에 영향을 주지 않는다고 되어있습니다.
컴포넌트 단위로 관리하기 때문에 필요하다면 이전 버전을 사용하면 되니깐요.
또한 119p는 빌드 순서만을 말하고 있기도 하구요.

헷갈리신 것 같은거와 별개로 규훤님께서 궁금하신 것 같은 기능 추가의 주기가 길어지는 현상은 일어나지 않을까 생각됩니다.
의존하고 있는 컴포넌트의 이전 버전을 사용하면서 기능을 만들어두고 배포하면 되니깐요.
만약 모든 컴포넌트 릴리스를 꼭 올려야만 기능 추가가 가능하다면 순환 참조되고 있는 구조가 아닐까싶네요 .
```

```text
진호:
REP는 단일 컴포넌트는 응집성 높은 요소들로 구성되어야 한다.
CCP는 응집성 높은 요소들만을 단일 컴포넌트로 구성해야 한다.
REP가 지켜지면 CCP도 저절로 지켜지고 그 반대도 아닌가 싶은 생각이 듭니다.
무슨 차이점이 있나요?

대답: 진영님 질문하고 상당히 유사하네요 ㅎㅎ
진영님 질문에 대한 대답으로 대체하도록 하겠습니다!
```


```text
천규: 
13장에서 제가 이해한 바로는 클래스 B가 클래스 A에 의존할 경우 (A ← B) CCP에 의해 둘은 같은 컴포넌트에 있어야 합니다.
그렇다면 서로 다른 다수의 클래스가 연속적으로 의존하는 형태를 지니는 상황(A ← B ← C ← D ← ...)에서는
컴포넌트 구조를 어떻게 만드는 것이 좋을까요?

A의 변경이 하위 클래스들의 변경을 유발할 가능성이 높으니 모두 한 컴포넌트에 배치해야 할 것 같기도 하고,
직접적인 의존이 없는 클래스가 많아 분리해야 할 것 같기도 합니다.
(ex. D는 A, B에 직접 의존하지는 않으므로 A, B와 다른 컴포넌트에 존재해야 하는가?)

쓰고 보니 이게 CCP와 CRP의 충돌인가? 라는 생각이 드네요. 사실 두 원칙의 차이도 확실하게 이해되질 않습니다.
그냥 해당 클래스들의 의존관계를 개선하는게 근본적인 해결책인가 싶기도 하고...
부디 이 어리석은 중생을 구원해 주시면 감사하겠습니다.

대답: 
일단 B, C, D... 들이 A 변경에 의해 변경된다면 이것부터 따져야 할 것 같습니다.
동일한 시점에 동일한 이유로 변경되었는가? (CCP)
이를 따졌을 때 모든 클래스들이 동일한 이유로 변경된다면 한 컴포넌트에 있는게 맞습니다.

또한 이게 한 컴포넌트라고 봤을 때 CRP도 만족하게 됩니다.
모든 클래스가 동일한 이유, 즉 목적이 같은 애들끼리 강하게 의존하고 있기 때문에
해당 컴포넌트는 재사용성이 높아지겠죠.

즉 예시로 주신 상황만으로는 판단하기 힘듭니다.

CCP와 CRP는 어쩔 수 없이 충돌이 나는 개념들입니다.
CCP는 포함, CRP는 배제 원칙이기 때문이죠.

그리고 두 원칙의 차이도 명확하게 구분짓기 힘든것도 당연합니다.
CCP는 SRP와, CRP는 ISP와 비슷하기 때문이죠.
CCP 즉 서로 다른 시점에 다른 이유로 변경되는 것들은 분리해라.
CRP 즉 컴포넌트에 사용하지 않는 클래스를 의존하지 마라.

클래스들의 의존관계를 개선하는건 언제나 근본적인 문제입니다.
SOLID가 제대로 지켜지지 않고는 컴포넌트 결합을 말할 수는 없죠.
위에서 말한 것들은 SOLID가 지켜졌다는 전제로 말씀드렸습니다.
```
