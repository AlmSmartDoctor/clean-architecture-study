# 진행 자료

# 컴포넌트 응집도

- 어떤 클래스를 어느 컴포넌트에 포함시켜야할까?
- 이는 중요한 결정이므로 제대로 된 소프트웨어 엔지니어링 원칙의 도움을 받아야한다.
- 하지만 우리는 임시방편적으로 결정을 내려왔다.

<br/>

- 이 장에서는 컴포넌트 응집도와 관련된 세 가지 원칙을 논의한다.
1. REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
2. CCP: 공통 폐쇄 원칙 (Common Closure Principle)
3. CRP: 공통 재사용 원칙 (Common Reuse Principle)

## REP: 재사용/릴리스 등가 원칙

| 재사용 단위는 릴리스 단위와 같다.

- 지난 십 년은 모듈 관리 도구가 우후죽순으로 등장한 시기였다.
- 이 기간에 재사용 가능한 컴포넌트나 라이브러리가 엄청나게 많이 만들어졌기 때문에, 이 같은 도구들은 점점 중요해졌다.

<br/>

- 돌이켜보면 REP는 너무 당연해 보인다.
- 컴포넌트가 추적 관리되지 않거나, 릴리스 번호가 부여되지 않는다면 재사용하고 싶어도 할 수 없고, 하지도 않을 것이다.
- 즉 릴리스에 충분한 정보가 있어야 개발자가 새 릴리스를 통합할지, 한다면 언제할지 결정할 수 있다.

<br/>

- 이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.
- 즉 컴포넌트를 구성하는 모든 모듈을 서로 공유하는 중요한 테마나 목적이 있어야한다.

<br/>

- 이 사실은 물론 너무 당연하다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 
1. 버전 번호가 같아야 하며 
2. 동일한 릴리스로 추적 관리되고
3. 동일한 문서에 포함되어야 한다
- 는 사실은 컴포넌트 제작자 입장이나 사용자 입장에서도 이치에 맞는 얘기다

<br/>

- 하지만 이 원칙의 조언은 약하다.
- 구체적인 해결 방법을 제시해주지는 못하기 때문이다.
- 이 원칙의 약점은 다음에 다룰 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있다.

## CCP: 공통 폐쇄 원칙 

| 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

- 이 원칙은 SRP를 컴포넌트 관점에서 다시 쓴 것이다.
- SRP에서 단일 클래스는 변겨의 이유가 여러 개 있어서는 안 된다고 말하듯이, CCP에서도 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다고 말한다.

<br/>

- 대다수의 어플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
- 어플리케이션 코드가 반드시 변경되어야한다면, 변경 사항이 여러 컴포넌트에 분산되어 발생하는 것보다, 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.
- 변경된 컴포넌트만 재배포하면 되기 때문이다.

<br/>

- CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.
- 이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.

<br/>

- 이 원칙은 OCP와도 밀접하게 관련되어 있다.
- OCP에서 말하는 폐쇄와 CCP에서 말하는 폐쇄와 뜻이 같다. 즉 변경에 닫혀있어야한다.
- 하지만 100% 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄해야 한다.
- 따라서 변경이 생겼을 때, 그 변경으로 영향을 받는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.

<br/>

## CRP: 공통 재사용 원칙

| 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

- CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다.
- 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용 하는 경우가 많다.
- 간단한 사례로 컨테이너 클래스와 해당 클래스의 이터레이터 클래스를 들 수 있다.
- 이 클래스들은 강하게 결합되어 있기 때문에, 이 클래스들은 반드시 동일한 컴포넌트에 위치해야 한다.

<br/>

- CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.
- 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생긴다.
- 어쩌면 단 하나의 클래스만 사용하는 상황일 수도 있다. 하지만 그렇다고 해서 의존성은 조금도 약해지지 않는다.
- 이 같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다.
- 따라서 의존해야 하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.

<br/>

- 바꿔 말하면, 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다.
- 즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다.
- 따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다.

## 컴포넌트 응집도에 대한 균형 다이어 그램

- 응집도에 관한 세 원칙이 서로 상충된다는 것은 눈치챘을 것이다.
- REP와 CCP는 포함 원칙이다.
- 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.
- CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만든다.

![](https://velog.velcdn.com/images/eplue/post/38cf3965-ecb6-415c-9b52-21568de1f674/image.png)

- 오로지 REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다.
- 반대로 CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.
- 뛰어난 아키텍트라면 이 규현 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 한다.
- 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편이며, 이 때는 오직 재사용성만 희생하면 된다.
- 점차 프로젝트가 성숙해지면서, 프로젝트는 점차 왼쪽으로 이동해간다.

# 컴포넌트 결합

- 지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.
- 이 장에서 만찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다.
- 컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.

## ADP: 의존성 비순환 원칙

| 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

- 하루 종일 일해서 무언가를 작동하게 만들고, 다음날 출근해보면 돌아가지 않는 경험을 해본적이 있지 않은가?
- 왜냐하면 누군가 단신이 의존하고 있던 무언가를 수정했기 때문이다.
- 저자는 이런 현상을 '숙취 증후군'이라고 부른다.

<br/>

- 숙취 증후군은 소수의 개발자로 구성된 상대적으로 작은 프로젝트에서는 이 증후군이 그다지 큰 문제가 되지 않는다.
- 하지만 프로젝트와 개발팀의 규모가 커지면 숙취는 지독한 악몽이 될 수도 있다.
- 지난 수십년간 이 문제의 해결책으로 두 가지 방법이 발전되어 왔다.
- 첫 번째 해결책은 '주 단위 빌드'이며
- 두 번째 해결책은 '의존성 비순환 원칙'이다

## 주 단위 빌드 (Weekly Build)

- 주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다.
- 주 단위 빌드를 하는 방법은 다음과 같다.
1. 모든 개발자들은 4일 동안 서로 신경쓰지 않고 개발한다. 즉 어떻게 통합할지 걱정하지 않는다.
2. 그런 후 4일이 지나면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
- 이 접근법은 5일 중 4일동안 개발자를 고립된 세계에서 살 수 있게 보장해준다는 아주 멋진 장점을 가진다.
- 물론 단점은 금요일에 통합과 관련된 막대한 업보를 치러야 한다는 사실이다.

<br/>

- 안타깝게도 프로젝트가 커지면 프로젝트 통합은 금요일 하루 만에 끝마치는게 불가능해진다.
- 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.
- 이 같은 흐름은 마침내 위기를 초래한다.
- 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다.

## 순환 의존성 제거하기

- 이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
- 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
- 해당 개발자는 컴포넌트를 동작하게 만든 후 다른 개발자가 사용할 수 있도록 컴포넌트를 릴리스한다.
- 컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결정해야 한다.
- 적용하지 않기로 했다면 그냥 과거 버전의 릴리스를 계속 사용한다.
- 따라서 어떤 팀도 다른 팀에 의해 좌우되지 않는다.
- 각 팀은 새롭게 릴리스된 특정 컴포넌트에 맞춰 수정할 시기를 스스로 결정할 수 있다.
- 즉 통합은 작고 점진적으로 이루어진다.

<br/>

- 이 방식은 단순하며 합리적이어서 널리 사용되는 방식이다.
- 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.
- 의존성 구조에 순환이 있어서는 안 된다.

![](https://sungjk.github.io/images/2019/10/26/14_1.png)

- 위 다이어그램에서는 컴포넌트를 조립하여 어플리케이션을 만드는 다소 전형적인 구조를 볼 수 있다.
- 중요한 점은 컴포넌트 간의 의존성 구조다.
- 한 가지 더 주목할 점이 있다. 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아 갈 수 없다는 것이다.
- 즉 비순환 방향 그래프다.

<br/>

- 이제 Presenters를 담당하는 팀에서 이 컴포넌트의 새로운 릴리스를 만들면 무슨 일이 벌어질지를 생각해보자.
- 이 릴리스에 영향받는 팀은 의존성 화살표를 거꾸로 따라가면 쉽게 찾을 수 있다.
- 즉 View, Main 컴포넌트 둘 다 영향을 받는다.
- 이 두 컴포넌트를 작업 중인 개발자라면, Presenter의 새로운 릴리스와 자신의 작업물을 언제 통합할지를 반드시 결정해야 한다.
- 또한 Main은 새로 릴리스되더라도 시스템에서 이로 인해 영향받는 컴포넌트가 전혀 없다는 사실에 주목하자.
- 나머지 컴포넌트는 Main에 대해 알지 못하므로 Main이 변경되더라도 전혀 개의치 않는다.

<br/>

- Presenters 컴포넌트를 만드는 개발자가 이 컴포넌트를 테스트하고자 한다면, 단순히 현재 사용 중인 버전의 Interactors와 Entities를 이용해서 Presenters 자체 버전을 빌드하면 그만이다.
- 이 빌드 과정에서 시스템의 나머지 컴포넌트는 전혀 관련이 없다.
- 즉 테스트를 구성할 때 적은 노력이 든다는 것이며, 고려해야할 변수도 상대적으로 적다는 뜻이기도 하다.

<br/>

- 시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.
- 먼저 Entities 컴포넌트를 컴파일하고, 테스트하고, 릴리스한다.
- 그리고 나서 Database와 Interactors에 대해서도 동일한 과정을 거친다.
- Main은 마지막에 처리한다.
- 이 처럼 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다.

## 순환이 컴포넌트 의존성 그래프에 미치는 영향

- 새로운 요구사항이 발생해서 Entities에 포함된 클래스 하나가 Authorizer에 포함된 클래스 하나를 사용하도록 변경할 수밖에 없다고 가정해보자.
- 예를 들어 Entities의 User 클래스가 Authorizer의 Permissions 클래스를 사용한다고 해보자.
- 그럼 아래 그림과 같이 순환 의존성이 발생한다.

![](https://uchanlee.dev/static/6005b83720c2dd84929d83b923528691/0a47e/image-14.2.png)

- 이 순환은 즉각적인 문제를 일으킨다.
- 예를 들어, Database 컴포넌트를 만드는 개발자는 컴포넌트를 릴리스 하려면 Entities 컴포넌트와 반드시 호환되어야 한다는 사실을 알고있다.
- 하지만 Entities 컴포넌트에는 순환이 있으므로, Database 컴포넌트 또한 Authorizer와도 호환되어야한다.
- 그런데 Authorizer는 Interacto에 의존한다.
- 즉 Entities, Authorizer, Interactors는 사실상 하나의 거대한 컴포넌트가 되어버린다.
- 즉 이 컴포넌트들 중 어느 것을 개발하더라도 '숙취 증후군'에 떠는 경험을 하게 될 거라는 의미다.

<br/>

- 하지만 이는 겪게 될 문제 중 일부일 뿐이다.
- Entities 컴포넌트를 테스트할 때 무슨일이 벌어질지를 생각해보라.
- 유감스럽게도 Authorizer와 Interactors까지도 반드시 빌드하고 통합해야 한다.
- 뿐만 아니라 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.
- 사실 순환이 생기면 올바른 순서라는게 없을 수 있다.

## 순환 끊기

- 컴포넌트 사이의 순환을 끊고 의존성을 다시 비순환 방향 그래프로 원상복구하는 일은 언제라도 가능하다.
- 이를 위한 주요 메커니즘 두 가지를 살펴보자.

<br/>

1. DIP를 적용한다.

![](https://uchanlee.dev/static/7f579cd6cb89c723fb56ee99dd4f20e5/0a47e/image-14.3.png)

- 위 그림처럼 User가 필요로 하는 메서드를 제공하는 인터페이스를 생성한다.
- 그리고 이 인터페이스는 Entities에 위치시키고, Authorizer에서는 이 인터페이스를 상속받는다.
- 이렇게 하면 Entities와 Authorizer 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.

<br/>

2. Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다.

![](https://uchanlee.dev/static/d6ca8fdc9c1a119dc7da195141d491d3/0a47e/image-14.1.png)

- 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 옮긴다.

## 흐트러짐 (Jitters)

- 두 번째 해결책에서 시사하는 바는 요구사항이 변경되면서 컴포넌트 구조도 변경될 수 있다는 사실이다.
- 실제로 어플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다.
- 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다.

## 하향식 (top-down) 설계


---

# 질의응답

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
규훤:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진호:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```


```text
천규:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
준우:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
이영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
영재:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
태훈:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
가온:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```
