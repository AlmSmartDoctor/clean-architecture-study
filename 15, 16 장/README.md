# 진행 자료

---

# 15장 - 아키텍처란?
> "소프트웨어 시스템의 아키텍처란, 시스템을 구축했던 사람들이 만들어낸 시스템의 형태다." [142p]

- `소프트웨어 시스템을 구성하는 컴포넌트들과 그 컴포넌트들의 상호관계에 대한 정의` 라고도 할 수도 있을 것 같습니다.

## <U>아키텍처의 목적</U>
### [시스템의 생명주기](https://ko.myservername.com/sdlc-phases)를 지원하는 것
= 아래의 과정들이 원활하게 이루어지도록 하는 것
- ### 개발
  - 개발자(프로그래머)들의 상황에 적합한 시스템을 설계해야 한다.
    - 소규모의 팀이 복잡하지 않은 프로그램을 개발한다면, 잘 정의된 컴포넌트/인터페이스 없이 모노리틱(monolithic) 시스템을 개발할 수 있다.
    - 다수의 팀이 함께 대규모 프로그램을 개발한다면, 잘 설계된 컴포넌트 단위로 분리하지 않고 개발하기는 어렵다.
- ### 배포
  - 배포 비용이 높을수록 소프트웨어 시스템의 유용성은 떨어진다.
  - 초기 개발 단계에서 배포 전략을 고려하지 않는다면, 개발은 쉬워도 배포하기는 어려워질 수 있다.
  - 예시: [마이크로서비스 아키텍처](https://giljae.medium.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-microservices-architecture-%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-7c45615cfe1a)
    - 각 모듈의 개발은 비교적 쉬울 수 있지만 모듈이 많아지면 최종적으로 모듈을 연결하는 과정이 어렵고 위험해짐
- ### 운영
  - 개발, 배포, 유지보수에 비해 영향이 적다
    - 운영이 힘든 아키텍처의 비용 <<< 개발/배포/유지보수가 힘든 아키텍처의 비용
  - 비효율적 운영으로 인해 발생하는 대부분의 문제는 단순히 하드웨어를 더 투입하는 것만으로도 해결할 수 있다.
  - 그러나 운영하기 쉬운 아키텍처는 개발자가  유스케이스, 기능, 시스템의 필수 행위 등을 더 잘 인식할 수 있도록 하며, 결과적으로 개발과 유지보수에 큰 도움을 준다.
- ### 유지보수
  - 전반적으로 비용이 가장 많이 발생하는 부분
    - 추가 개발을 위한 탐사(spelunking) 비용
    - 추가 개발로 인해 발생하는 결함을 수정하는 비용
  - 잘 분리된 컴포넌트를 안정된 인터페이스로 격리하면 부담이 감소


## <U>아키텍처의 목적을 달성하려면?</U>
- ### `세부사항`의 가능성을 최대화하기 (선택사항 열어 두기)
  - 세부사항 ≡ `고수준의 정책을 이용할 때 필요하지만 - 정책이 가진 행위에 어떠한 영향도 미치치 않는 요소`
    - 입출력 장치
    - 데이터베이스 (관계형/분산형/계층형/...)
    - 웹 시스템
    - 서버
    - 프레임워크 (의존성 주입 프레임워크를 사용해야 할까? -> 고민 X)
    - 통신 프로토콜 (TCP, HTTP, ...)
  - <U>고수준의 정책을 먼저 설계하고, 세부 사항에 대한 결정은 나중으로 미루는 것.</U>
    - 더 많은 정보를 얻고 그에 기반하여 더 올바른 결정을 내릴 수 있음.
    - 현재 작동중인 고수준 정책에 대해 다양한 세부사항의 적용 가능성과 성능 검토 가능.
- ### 예시 1) 장치 독립성
  - 1960년대 사용되던 천공 카드를 자기 테이프로 교체하고자 함
  - 그러나 기존의 프린터 소프트웨어는 오직 카드 판독기와 카드 천공기를 조작하도록 작성됨.
  - 자기 테이프를 이용하기 위해서는 소프트웨어를 완전히 다시 만들어야 하는 상황이 발생.
  - 이러한 장치 의존성을 해결하기 위해 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화함
  - ![device_independence](https://user-images.githubusercontent.com/89779756/176947162-2d106fec-83b4-4761-aeb1-28f47e285a4d.png)
- ### 예시 2) 물리적 주소 할당
  - 글쓴이는 지역 트럭 운전수 조합을 위한 대규모 회계 시스템을 만든 적이 있음
    - 25MB 디스크 드라이브에 Agent, Employer, Member 등 제각각의 레코드 저장
    - 디스크의 몇 실린더를 포맷하여 각 섹터가 단일 Agent 레코드 크기와 동일하도록 설계
    - Employer와 Member도 동일하게 설계
    - 각 레코드를 탐색할 수 있는 색인을 저장 (실린더 번호, 섹터 번호 등 포함)
    - 소프트웨어가 상기한 디스크의 구조를 알고 있도록 개발 (하드코딩)
  - ### 여기서 디스크를 업그레이드한다면 어떨까?
    - 이전의 디스크에서 데이터를 읽어 새로운 디스크로 옮겨야 함
    - 그러나, 실린더/섹터의 크기가 다르므로 해당 요소를 변환하는 특수 프로그램이 필요
    - 심지어 소프트웨어에 하드코딩된 레코드 크기 등을 수정해야함
  - > "어느 날 우리보다 노련한  프로그래머가 우리 조직에 합류했다. 그는 우리가 해놓은 일을 보고 나서 
       얼굴이 창백해졌다. 그리고 마치 우리가 무슨 외계인인 양 기겁을 하며 쳐다봤다. 그러면서 친절하게 
       주소 할당 체계를 변경하여 상대 주소를 사용하라고 충고해 주었다."
  
- ### 결론: 좋은 아키텍처에서 정책은 세부사항에 의존하지 않아야 한다.
---

# 16장 - 독립성


---

# 질의응답

```text
지인:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
규훤:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진호:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
준우:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
성준:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
이영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
영재:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
태훈:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
가온:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```