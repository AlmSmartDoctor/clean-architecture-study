# 진행 자료

---

# 15장 - 아키텍처란?
> "소프트웨어 시스템의 아키텍처란, 시스템을 구축했던 사람들이 만들어낸 시스템의 형태다." [142p]

- `소프트웨어 시스템을 구성하는 컴포넌트들과 그 컴포넌트들의 상호관계에 대한 정의` 라고도 할 수도 있을 것 같습니다.

## <U>아키텍처의 목적</U>
### [시스템의 생명주기](https://ko.myservername.com/sdlc-phases)를 지원하는 것
= 아래의 과정들이 원활하게 이루어지도록 하는 것
- ### 개발
  - 개발자(프로그래머)들의 상황에 적합한 시스템을 설계해야 한다.
    - 소규모의 팀이 복잡하지 않은 프로그램을 개발한다면, 잘 정의된 컴포넌트/인터페이스 없이 모노리틱(monolithic) 시스템을 개발할 수 있다.
    - 다수의 팀이 함께 대규모 프로그램을 개발한다면, 잘 설계된 컴포넌트 단위로 분리하지 않고 개발하기는 어렵다.
- ### 배포
  - 배포 비용이 높을수록 소프트웨어 시스템의 유용성은 떨어진다.
  - 초기 개발 단계에서 배포 전략을 고려하지 않는다면, 개발은 쉬워도 배포하기는 어려워질 수 있다.
  - 예시: [마이크로서비스 아키텍처](https://giljae.medium.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-microservices-architecture-%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-7c45615cfe1a)
    - 각 모듈의 개발은 비교적 쉬울 수 있지만 모듈이 많아지면 최종적으로 모듈을 연결하는 과정이 어렵고 위험해짐
- ### 운영
  - 개발, 배포, 유지보수에 비해 영향이 적다
    - 운영이 힘든 아키텍처의 비용 <<< 개발/배포/유지보수가 힘든 아키텍처의 비용
  - 비효율적 운영으로 인해 발생하는 대부분의 문제는 단순히 하드웨어를 더 투입하는 것만으로도 해결할 수 있다.
  - 그러나 운영하기 쉬운 아키텍처는 개발자가  유스케이스, 기능, 시스템의 필수 행위 등을 더 잘 인식할 수 있도록 하며, 결과적으로 개발과 유지보수에 큰 도움을 준다.
- ### 유지보수
  - 전반적으로 비용이 가장 많이 발생하는 부분
    - 추가 개발을 위한 탐사(spelunking) 비용
    - 추가 개발로 인해 발생하는 결함을 수정하는 비용
  - 잘 분리된 컴포넌트를 안정된 인터페이스로 격리하면 부담이 감소


## <U>아키텍처의 목적을 달성하려면?</U>
- ### `세부사항`의 가능성을 최대화하기 (선택사항 열어 두기)
  - 세부사항 ≡ `고수준의 정책을 이용할 때 필요하지만 - 정책이 가진 행위에 어떠한 영향도 미치치 않는 요소`
    - 입출력 장치
    - 데이터베이스 (관계형/분산형/계층형/...)
    - 웹 시스템
    - 서버
    - 프레임워크 (의존성 주입 프레임워크를 사용해야 할까? -> 고민 X)
    - 통신 프로토콜 (TCP, HTTP, ...)
  - <U>고수준의 정책을 먼저 설계하고, 세부 사항에 대한 결정은 나중으로 미루는 것.</U>
    - 더 많은 정보를 얻고 그에 기반하여 더 올바른 결정을 내릴 수 있음.
    - 현재 작동중인 고수준 정책에 대해 다양한 세부사항의 적용 가능성과 성능 검토 가능.
- ### 예시 1) 장치 독립성
  - 1960년대 사용되던 천공 카드를 자기 테이프로 교체하고자 함
  - 그러나 기존의 프린터 소프트웨어는 오직 카드 판독기와 카드 천공기를 조작하도록 작성됨.
  - 자기 테이프를 이용하기 위해서는 소프트웨어를 완전히 다시 만들어야 하는 상황이 발생.
  - 이러한 장치 의존성을 해결하기 위해 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화함
  - ![device_independence](https://user-images.githubusercontent.com/89779756/176947162-2d106fec-83b4-4761-aeb1-28f47e285a4d.png)
- ### 예시 2) 물리적 주소 할당
  - 글쓴이는 지역 트럭 운전수 조합을 위한 대규모 회계 시스템을 만든 적이 있음
    - 25MB 디스크 드라이브에 Agent, Employer, Member 등 제각각의 레코드 저장
    - 디스크의 몇 실린더를 포맷하여 각 섹터가 단일 Agent 레코드 크기와 동일하도록 설계
    - Employer와 Member도 동일하게 설계
    - 각 레코드를 탐색할 수 있는 색인을 저장 (실린더 번호, 섹터 번호 등 포함)
    - 소프트웨어가 상기한 디스크의 구조를 알고 있도록 개발 (하드코딩)
  - ### 여기서 디스크를 업그레이드한다면 어떨까?
    - 이전의 디스크에서 데이터를 읽어 새로운 디스크로 옮겨야 함
    - 그러나, 실린더/섹터의 크기가 다르므로 해당 요소를 변환하는 특수 프로그램이 필요
    - 심지어 소프트웨어에 하드코딩된 레코드 크기 등을 수정해야함
  - > "어느 날 우리보다 노련한  프로그래머가 우리 조직에 합류했다. 그는 우리가 해놓은 일을 보고 나서 
       얼굴이 창백해졌다. 그리고 마치 우리가 무슨 외계인인 양 기겁을 하며 쳐다봤다. 그러면서 친절하게 
       주소 할당 체계를 변경하여 상대 주소를 사용하라고 충고해 주었다."
  
- ### 결론: 좋은 아키텍처에서 정책은 세부사항에 의존하지 않아야 한다.

책의 도입부에서 말한 `변경이 쉬운 프로그램을 만드는 것`이 좋은 아키텍처의 목적이라고 볼 수도 있겠네요.

---

# 16장 - 독립성
좋은 아키텍처는 다음을 지원해야 한다:
- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

### 유스케이스

- 유스케이스 ≡ 소프트웨어가 수행하고자 하는 역할, 즉 프로그램의 `기능`
  - ex) 스마트차트의 유스케이스:
    - 로그인 (사용자 인증)
    - 의료 차트 조회 / 저장
    - 진료 이미지 조회 / 저장
    - 진료 정보(상병, 증상, 처방, etc.) 조회 / 저장
    - 기타등등
- <U>아키텍처의 최우선 관심사</U>
- 이러한 유스케이스가 잘 구현될 수 있도록 하기 위해 아키텍처가 할 수 있는 것은?
  - 유스케이스/행위를 명확히 하고 외부로 드러냄
  - 시스템 구조에서 한눈에 드러나는 유스케이스는 **일급 요소(first-class element)** 라고도 하며, 아키텍처 내에서 핵심적인 클래스, 함수, 또는 모듈로서 존재함.
  - --> 결과적으로 개발 및 유지보수가 쉬워진다

### 운영

- 운영 관점에서 아키텍처는 더 실질적인 역할을 맡음.
- 시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 함.
- 이러한 운영 형태를 지원하기 위해 생각할 수 있는 아키텍처:
  - 유스케이스를 일련의 작은 서비스들로 배열하여 다수의 서버에서 병렬적으로 처리하도록 하는 아키텍처
  - 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만드는 아키텍처
- 아키텍트는 이러한 사항의 결정을 미루고 가능성을 열어두어야 한다.
  - 만약 운영에 필요한 요구사항이 변경된다면? (ex. 고객 수 100,000 -> 100,000,000)
  - 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요할 수 있는데, 이 경우 모노리틱 프로그램은 개선이 어려움.
  - 그에 비해 다양한 컴포넌트로 적절히 격리되고 각 컴포넌트 간 통신 방식이 제한되지 않은 프로그램이라면, 기술 스펙트럼을 전환하는 것이 훨씬 쉬움.

### 개발

> 콘웨이(Melvin Conway)의 법칙: <br/><br/> "시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다."

- 많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 확보해야 한다.
- 즉, 시스템을 `독립적으로 개발 가능한 컴포넌트 단위`로 분할하여야 한다.

### 배포

- 좋은 아키텍처는 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
- 이를 위해서 시스템은 컴포넌트 단위로 잘 분할되고 격리되어야 한다.
  - 이 때 분할/격리되는 컴포넌트에는 마스터(메인) 컴포넌트도 포함된다.
  - 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동 / 통합 / 관리해야 한다.

<br/>

하지만 현실적으로는 상기한 컴포넌트 구조와 관련된 관심사들(유스케이스, 운영, 개발, 배포, etc.) 사이에서
균형을 맞추기 어렵다. 그 이유는:
- 모든 유스케이스를 알 수는 없다.
- 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항을 모두 알 수는 없다.
- 이러한 사항들을 알아도, 시스템의 생명주기를 거치며 해당 사항들은 변화한다.
- 즉, 우리의 목표가 지속적으로 변화하게 된다.

그렇기 때문에 시스템을 변경하기 쉬운 구조(아키텍처), 분리를 통한 독립성 확보가 중요한 것이다.

## 계층 결합 분리 (SRP + CCP)

- 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고(SRP), 동일한 이유로 변경되는 것들은 묶는다(CCP).
  - 예를 들어 사용자 인터페이스, 업무 규칙, 데이터베이스 등은 서로 관련이 없다. 다시 말해, 각각은 다른 이유로 인해 다른 속도로 변경된다.
  - 따라서 상기한 요소들은 별개의 수평적 계층으로 분리되어야 한다.

## 유스케이스 결합 분리

- 유스케이스는 여러 종류가 존재하고, 각 유스케이스는 서로 다른 이유로 변경된다. 따라서 유스케이스 또한 서로 분리되어야 한다.
- 유스케이스는 시스템의 수평적인 계층을 가로지르는 조각으로도 생각할 수 있다.
  - 각 유스케이스는 UI의 일부, 업무 규칙의 일부, 데이터베이스 기능의 일부를 필요로 한다.
  - 따라서 아래의 그림과 같은 구조를 생각해 볼 수 있다.<br/> ![115108649-994bb900-9fac-11eb-891b-d92b13d819c3](https://user-images.githubusercontent.com/89779756/176991495-823bc540-bf83-45be-ab97-ca5f27979387.png)
  - 이렇게 분리된 구조가 있다면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다.


## 개발 독립성

- 업뮤 규칙이 UI를 알지 못하면 UI를 담당하는 팀은 업무 규칙을 담당하는 팀에 큰 영향을 줄 수 없다.
- 유스케이스 결합이 분리되면 `주문 추가`를 담당하는 팀이 `주문 삭제`를 담당하는 팀에 개입할 가능성이 낮아진다.
- 즉, 충돌의 가능성을 낮춤으로 인해 원할한 개발이 가능해진다.

## 배포 독립성

- 유스케이스와 계층의 결합이 분리되어 있다면 운영 중인 시스템에서도 계층과 유스케이스를 교체(hot-swap)* 할 수 있다.
- 따라서 배포의 유연성이 향상된다.

*hot-swap : 운영 중인 시스템에서 런타임에 새로운 jar 파일이나 서비스를 추가할 수 있는 능력 (옮긴이)

## 중복

- 코드의 `진짜 중복`과 `가짜 중복`을 구분할 수 있어야 한다.
  - 진짜 중복: 하나의 인스턴스가 변경되면 해당 변경사항이 다른 모든 복사본 인스턴스에 적용되어야 하는 경우.
  - 가짜 중복: 현재는 동일해 보여도 각 코드가 각자의 경로로 발전하는 경우
- 가짜 중복 경험담: 스마트차트 동의서 목록과 진료이미지 목록
  - 서로 다른 두 팝업이 같은 레이아웃(UI)을 공유하고 있었음
  - 진료이미지 목록 팝업에 "다중 선택 기능"이 추가됨.
  - 진료이미지 목록 레이아웃에 Switch를 추가하자, 동의서 팝업에도 해당 스위치가 나타나버림.
  - 결국 동의서 목록 팝업의 레이아웃을 뒤늦게 따로 생성하게 됨.
- 유스케이스와 계층을 분리할 때 비슷한 화면 구조 / 알고리즘 / 데이터베이스 쿼리 및 스키마 등으로 인해 통합하고 싶을 때는 `진짜 중복`인지 꼼꼼한 확인이 필요.

## 결합 분리 모드

- 운영 관점에서 유스케이스/계층 결합의 분리는 상당한 도움이 된다.
- 유스케이스에서 서로 다른 관점이 분리되었다면, 유스케이스들은 필요한 처리량에 따라 분리되어 있을 가능성이 높다.
- 그리고 UI와 데이터베이스가 업무 규칙과 분리되어 있다면, [UI & 데이터베이스]는 업무 규칙과 다른 서버에서 실행될 수 있다.
  - 높은 대역폭을 요구하는 유스케이스는 여러 서버로 복제하여 실행하는 등의 운영이 가능.


- 운영 측면에서 이러한 이점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 한다.
- 예를 들어 분리된 컴포넌트가 서로 다른 서버에서 실행되야 하는 상황이라면:
  - 각 컴포넌트는 독립된 서비스가 되어야 한다.
  - 컴포넌트들은 일종의 네트워크를 통해 서로 통신해야 한다.
- 이러한 컴포넌트를 `서비스(service)` 또는 `마이크로서비스(micro service)` 라고도 한다. (둘의 구분 기준은 모호함)
- 서비스에 기반한 아키텍처는 `서비스 지향 아키텍처(service_oriented architecture, SOA)`라고 부른다.

### [결합 분리 모드의 종류](https://velog.io/@gooreum_90/%EA%B2%BD%EA%B3%84-%ED%95%B4%EB%B6%80%ED%95%99):
- ### 소스 수준 분리 모드
  - 소스 코드 모듈 사이의 의존성 제어 가능.
  - 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않아도 됨.
  - 모든 컴포넌트가 같은 주소 공간에서 실행되고, 간단한 함수 호출을 통해 서로 통신함.
  - 모노리틱 구조라고 부름.
- ### 배포 수준 분리 모드
  - 배포 가능한 단위들(jar 파일, DLL, 공유 라이브러리 등) 사이의 의존성 제어 가능.
  - 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않아도 됨.
  - 여전히 많은 컴포넌트가 같은 주소 공간에 상주하며, 간단한 함수 호출로 통신할 수 있음.
  - 배포 가능한 단위로 분류되어 소스 수준 분리 모드에 비해 배포가 비교적 편리. 그 외에는 유사함.
- ### 서비스 수준 분리 모드
  - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있음
  - 네트워크 패킷을 통해서만 통신하도록 만들 수 있음.
  - 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 됨

<br/>

#### 프로젝트 초기에는 어떤 모드가 최선인지 알기 어렵다.
- 시스템이 한 서버에서 실행되는 동안은 결합을 소스 수준에서 분리하는 것만으로도 충분
- 시스템의 규모가 커저 일부 컴포넌트를 별도의 서버에서 실행해야 한다면 배포 수준 분리, 더 나아가 서비스 수준 분리가 필요할 수 있음.


- 한 가지 해결책은 단순히 `서비스 수준에서의 분리`를 기본 정책으로 삼는 것.
- 그러나 필요치도 않은 서비스 경계를 처리하는 데 상당한 비용이 발생할 수 있다는 단점이 있음.


- 저자는 컴포넌트가 서비스화 될 가능성이 있다면 다음과 같이 대응:
  - 컴포넌트 결합을 분리하되
  - 서비스가 되기 직전에 멈춤
  - 그리고 컴포넌트들을 가능한 한 오랫동안 동일한 주소 공간에 남겨둠.
  - --> 서비스에 대한 선택사항이 열려있게 됨.

저자의 방식을 선택할 경우 다음과 같은 흐름이 발생:
> <U>초기:</U> <br/> 컴포넌트를 소스 코드 수준에서 분리
> 
> <U>배포나 개발에서 문제가 생김:</U> <br/> 일부 결합을 배포 수준까지 분리해 대응 
> 
> <U>개발, 배포, 운영적인 문제가 증가:</U> <br/> 서비스 수준으로 전환할 배포 단위들을 신중히 선택한 후 시스템을 (서비스화 하는 방향으로) 변경해 나감
> 
> <U>운영 요구사항이 감소:</U> <br/> 서비스 수준에서 분리되어있던 것들이 배포, 혹은 소스 수준의 분리만으로 충분해질 수 있음.

## 결론:
- ### 결합 분리 모드를 배포 / 운영 상황에 따라 선택할 수 있는 아키텍처를 구현해야 한다.
- 근데 좀 어렵다.
- 하기 싫으면 뛰어난 아키텍트가 되지 않으면 된다.

---

# 질의응답

```text
지인:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
규훤:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진호:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
준우:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
성준:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
이영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
영재:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
태훈:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
가온:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```