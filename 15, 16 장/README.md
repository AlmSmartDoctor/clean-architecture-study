# 진행 자료

---

# 15장 - 아키텍처란?
> "소프트웨어 시스템의 아키텍처란, 시스템을 구축했던 사람들이 만들어낸 시스템의 형태다." [142p]

- `소프트웨어 시스템을 구성하는 컴포넌트들과 그 컴포넌트들의 상호관계에 대한 정의` 라고도 할 수도 있을 것 같습니다.

## <U>아키텍처의 목적</U>
### [시스템의 생명주기](https://ko.myservername.com/sdlc-phases)를 지원하는 것
= 아래의 과정들이 원활하게 이루어지도록 하는 것
- ### 개발
  - 개발자(프로그래머)들의 상황에 적합한 시스템을 설계해야 한다.
    - 소규모의 팀이 복잡하지 않은 프로그램을 개발한다면, 잘 정의된 컴포넌트/인터페이스 없이 모노리틱(monolithic) 시스템을 개발할 수 있다.
    - 다수의 팀이 함께 대규모 프로그램을 개발한다면, 잘 설계된 컴포넌트 단위로 분리하지 않고 개발하기는 어렵다.
- ### 배포
  - 배포 비용이 높을수록 소프트웨어 시스템의 유용성은 떨어진다.
  - 초기 개발 단계에서 배포 전략을 고려하지 않는다면, 개발은 쉬워도 배포하기는 어려워질 수 있다.
  - 예시: [마이크로서비스 아키텍처](https://giljae.medium.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-microservices-architecture-%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-7c45615cfe1a)
    - 각 모듈의 개발은 비교적 쉬울 수 있지만 모듈이 많아지면 최종적으로 모듈을 연결하는 과정이 어렵고 위험해짐
- ### 운영
  - 개발, 배포, 유지보수에 비해 영향이 적다
    - 운영이 힘든 아키텍처의 비용 <<< 개발/배포/유지보수가 힘든 아키텍처의 비용
  - 비효율적 운영으로 인해 발생하는 대부분의 문제는 단순히 하드웨어를 더 투입하는 것만으로도 해결할 수 있다.
  - 그러나 운영하기 쉬운 아키텍처는 개발자가  유스케이스, 기능, 시스템의 필수 행위 등을 더 잘 인식할 수 있도록 하며, 결과적으로 개발과 유지보수에 큰 도움을 준다.
- ### 유지보수
  - 전반적으로 비용이 가장 많이 발생하는 부분
    - 추가 개발을 위한 탐사(spelunking) 비용
    - 추가 개발로 인해 발생하는 결함을 수정하는 비용
  - 잘 분리된 컴포넌트를 안정된 인터페이스로 격리하면 부담이 감소


## <U>아키텍처의 목적을 달성하려면?</U>
- ### `세부사항`의 가능성을 최대화하기 (선택사항 열어 두기)
  - 세부사항 ≡ `고수준의 정책을 이용할 때 필요하지만 - 정책이 가진 행위에 어떠한 영향도 미치치 않는 요소`
    - 입출력 장치
    - 데이터베이스 (관계형/분산형/계층형/...)
    - 웹 시스템
    - 서버
    - 프레임워크 (의존성 주입 프레임워크를 사용해야 할까? -> 고민 X)
    - 통신 프로토콜 (TCP, HTTP, ...)
  - <U>고수준의 정책을 먼저 설계하고, 세부 사항에 대한 결정은 나중으로 미루는 것.</U>
    - 더 많은 정보를 얻고 그에 기반하여 더 올바른 결정을 내릴 수 있음.
    - 현재 작동중인 고수준 정책에 대해 다양한 세부사항의 적용 가능성과 성능 검토 가능.
- ### 예시 1) 장치 독립성
  - 1960년대 사용되던 천공 카드를 자기 테이프로 교체하고자 함
  - 그러나 기존의 프린터 소프트웨어는 오직 카드 판독기와 카드 천공기를 조작하도록 작성됨.
  - 자기 테이프를 이용하기 위해서는 소프트웨어를 완전히 다시 만들어야 하는 상황이 발생.
  - 이러한 장치 의존성을 해결하기 위해 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화함
  - ![device_independence](https://user-images.githubusercontent.com/89779756/176947162-2d106fec-83b4-4761-aeb1-28f47e285a4d.png)
- ### 예시 2) 물리적 주소 할당
  - 글쓴이는 지역 트럭 운전수 조합을 위한 대규모 회계 시스템을 만든 적이 있음
    - 25MB 디스크 드라이브에 Agent, Employer, Member 등 제각각의 레코드 저장
    - 디스크의 몇 실린더를 포맷하여 각 섹터가 단일 Agent 레코드 크기와 동일하도록 설계
    - Employer와 Member도 동일하게 설계
    - 각 레코드를 탐색할 수 있는 색인을 저장 (실린더 번호, 섹터 번호 등 포함)
    - 소프트웨어가 상기한 디스크의 구조를 알고 있도록 개발 (하드코딩)
  - ### 여기서 디스크를 업그레이드한다면 어떨까?
    - 이전의 디스크에서 데이터를 읽어 새로운 디스크로 옮겨야 함
    - 그러나, 실린더/섹터의 크기가 다르므로 해당 요소를 변환하는 특수 프로그램이 필요
    - 심지어 소프트웨어에 하드코딩된 레코드 크기 등을 수정해야함
  - > "어느 날 우리보다 노련한  프로그래머가 우리 조직에 합류했다. 그는 우리가 해놓은 일을 보고 나서 
       얼굴이 창백해졌다. 그리고 마치 우리가 무슨 외계인인 양 기겁을 하며 쳐다봤다. 그러면서 친절하게 
       주소 할당 체계를 변경하여 상대 주소를 사용하라고 충고해 주었다."
  
- ### 결론: 좋은 아키텍처에서 정책은 세부사항에 의존하지 않아야 한다.

책의 도입부에서 말한 `변경이 쉬운 프로그램을 만드는 것`이 좋은 아키텍처의 목적이라고 볼 수도 있겠네요.

---

# 16장 - 독립성
좋은 아키텍처는 다음을 지원해야 한다:
- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

### 유스케이스

- 유스케이스 ≡ 소프트웨어가 수행하고자 하는 역할, 즉 프로그램의 `기능`
  - ex) 스마트차트의 유스케이스:
    - 로그인 (사용자 인증)
    - 의료 차트 조회 / 저장
    - 진료 이미지 조회 / 저장
    - 진료 정보(상병, 증상, 처방, etc.) 조회 / 저장
    - 기타등등
- <U>아키텍처의 최우선 관심사</U>
- 이러한 유스케이스가 잘 구현될 수 있도록 하기 위해 아키텍처가 할 수 있는 것은?
  - 유스케이스/행위를 명확히 하고 외부로 드러냄
  - 시스템 구조에서 한눈에 드러나는 유스케이스는 **일급 요소(first-class element)** 라고도 하며, 아키텍처 내에서 핵심적인 클래스, 함수, 또는 모듈로서 존재함.
  - --> 결과적으로 개발 및 유지보수가 쉬워진다

### 운영

- 운영 관점에서 아키텍처는 더 실질적인 역할을 맡음.
- 시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 함.
- 이러한 운영 형태를 지원하기 위해 생각할 수 있는 아키텍처:
  - 유스케이스를 일련의 작은 서비스들로 배열하여 다수의 서버에서 병렬적으로 처리하도록 하는 아키텍처
  - 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만드는 아키텍처
- 아키텍트는 이러한 사항의 결정을 미루고 가능성을 열어두어야 한다.
  - 만약 운영에 필요한 요구사항이 변경된다면? (ex. 고객 수 100,000 -> 100,000,000)
  - 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요할 수 있는데, 이 경우 모노리틱 프로그램은 개선이 어려움.
  - 그에 비해 다양한 컴포넌트로 적절히 격리되고 각 컴포넌트 간 통신 방식이 제한되지 않은 프로그램이라면, 기술 스펙트럼을 전환하는 것이 훨씬 쉬움.

### 개발

> 콘웨이(Melvin Conway)의 법칙: <br/><br/> "시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다."

- 많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 확보해야 한다.
- 즉, 시스템을 `독립적으로 개발 가능한 컴포넌트 단위`로 분할하여야 한다.

### 배포

- 좋은 아키텍처는 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
- 이를 위해서 시스템은 컴포넌트 단위로 잘 분할되고 격리되어야 한다.
  - 이 때 분할/격리되는 컴포넌트에는 마스터(메인) 컴포넌트도 포함된다.
  - 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동 / 통합 / 관리해야 한다.

<br/>

하지만 현실적으로는 상기한 컴포넌트 구조와 관련된 관심사들(유스케이스, 운영, 개발, 배포, etc.) 사이에서
균형을 맞추기 어렵다. 그 이유는:
- 모든 유스케이스를 알 수는 없다.
- 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항을 모두 알 수는 없다.
- 이러한 사항들을 알아도, 시스템의 생명주기를 거치며 해당 사항들은 변화한다.
- 즉, 우리의 목표가 지속적으로 변화하게 된다.

그렇기 때문에 시스템을 변경하기 쉬운 구조(아키텍처), 분리를 통한 독립성 확보가 중요한 것이다.

## 계층 결합 분리

- 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다. (CCP)
  - 예를 들어 사용자 인터페이스, 업무 규칙, 데이터베이스 등은 서로 관련이 없다. 다시 말해, 각각은 다른 이유로 인해 다른 속도로 변경된다.
  - 따라서 상기한 요소들은 별개의 수평적 계층으로 분리되어야 한다.

## 유스케이스 결합 분리

- 유스케이스는 여러 종류가 존재하고, 각 유스케이스는 서로 다른 이유로 변경된다. 따라서 유스케이스 또한 서로 분리되어야 한다.
- 유스케이스는 시스템의 수평적인 계층을 가로지르는 조각으로도 생각할 수 있다.
  - 각 유스케이스는 UI의 일부, 업무 규칙의 일부, 데이터베이스 기능의 일부를 필요로 한다.
  - 따라서 아래의 그림과 같은 구조를 생각해 볼 수 있다.<br/> ![115108649-994bb900-9fac-11eb-891b-d92b13d819c3](https://user-images.githubusercontent.com/89779756/176991495-823bc540-bf83-45be-ab97-ca5f27979387.png)
  - 이렇게 분리된 구조가 있다면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다.


## 개발 독립성

- 업뮤 규칙이 UI를 알지 못하면 UI를 담당하는 팀은 업무 규칙을 담당하는 팀에 큰 영향을 줄 수 없다.
- 유스케이스 결합이 분리되면 `주문 추가`를 담당하는 팀이 `주문 삭제`를 담당하는 팀에 개입할 가능성이 낮아진다.
- 즉, 충돌의 가능성을 낮춤으로 인해 원할한 개발이 가능해진다.

## 배포 독립성

- 유스케이스와 계층의 결합이 분리되어 있다면 운영 중인 시스템에서도 계층과 유스케이스를 교체(hot-swap)* 할 수 있다.
- 따라서 배포의 유연성이 향상된다.

*hot-swap : 운영 중인 시스템에서 런타임에 새로운 jar 파일이나 서비스를 추가할 수 있는 능력 (옮긴이)

## 중복

- 코드의 `진짜 중복`과 `가짜 중복`을 구분할 수 있어야 한다.
  - 진짜 중복: 하나의 인스턴스가 변경되면 해당 변경사항이 다른 모든 복사본 인스턴스에 적용되어야 하는 경우.
  - 가짜 중복: 현재는 동일해 보여도 각 코드가 각자의 경로로 발전하는 경우
- 가짜 중복 경험담: 스마트차트 동의서 목록과 진료이미지 목록
  - 서로 다른 두 팝업이 같은 레이아웃(UI)을 공유하고 있었음
  - 진료이미지 목록 팝업에 "다중 선택 기능"이 추가됨.
  - 진료이미지 목록 레이아웃에 Switch를 추가하자, 동의서 팝업에도 해당 스위치가 나타나버림.
  - 결국 동의서 목록 팝업의 레이아웃을 뒤늦게 따로 생성하게 됨.
- 유스케이스와 계층을 분리할 때 비슷한 화면 구조 / 알고리즘 / 데이터베이스 쿼리 및 스키마 등으로 인해 통합하고 싶을 때는 `진짜 중복`인지 꼼꼼한 확인이 필요.

## 결합 분리 모드

- 운영 관점에서 유스케이스/계층 결합의 분리는 상당한 도움이 된다.
- 유스케이스에서 서로 다른 관점이 분리되었다면, 유스케이스들은 필요한 처리량에 따라 분리되어 있을 가능성이 높다.
- 그리고 UI와 데이터베이스가 업무 규칙과 분리되어 있다면, [UI & 데이터베이스]는 업무 규칙과 다른 서버에서 실행될 수 있다.
  - 높은 대역폭을 요구하는 유스케이스는 여러 서버로 복제하여 실행하는 등의 운영이 가능.


- 운영 측면에서 이러한 이점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 한다.
- 예를 들어 분리된 컴포넌트가 서로 다른 서버에서 실행되야 하는 상황이라면:
  - 각 컴포넌트는 독립된 서비스가 되어야 한다.
  - 컴포넌트들은 일종의 네트워크를 통해 서로 통신해야 한다.
- 이러한 컴포넌트를 `서비스(service)` 또는 `마이크로서비스(micro service)` 라고도 한다. (둘의 구분 기준은 모호함)
- 서비스에 기반한 아키텍처는 `서비스 지향 아키텍처(service_oriented architecture, SOA)`라고 부른다.

### [결합 분리 모드의 종류](https://velog.io/@gooreum_90/%EA%B2%BD%EA%B3%84-%ED%95%B4%EB%B6%80%ED%95%99):
- ### 소스 수준 분리 모드
  - 소스 코드 모듈 사이의 의존성 제어 가능.
  - 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않아도 됨.
  - 모든 컴포넌트가 같은 주소 공간에서 실행되고, 간단한 함수 호출을 통해 서로 통신함.
  - 모노리틱 구조라고 부름.
- ### 배포 수준 분리 모드
  - 배포 가능한 단위들(jar 파일, DLL, 공유 라이브러리 등) 사이의 의존성 제어 가능.
  - 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않아도 됨.
  - 여전히 많은 컴포넌트가 같은 주소 공간에 상주하며, 간단한 함수 호출로 통신할 수 있음.
  - 배포 가능한 단위로 분류되어 소스 수준 분리 모드에 비해 배포가 비교적 편리. 그 외에는 유사함.
- ### 서비스 수준 분리 모드
  - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있음
  - 네트워크 패킷을 통해서만 통신하도록 만들 수 있음.
  - 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 됨

<br/>

#### 프로젝트 초기에는 어떤 모드가 최선인지 알기 어렵다.
- 시스템이 한 서버에서 실행되는 동안은 결합을 소스 수준에서 분리하는 것만으로도 충분
- 시스템의 규모가 커저 일부 컴포넌트를 별도의 서버에서 실행해야 한다면 배포 수준 분리, 더 나아가 서비스 수준 분리가 필요할 수 있음.


- 한 가지 해결책은 단순히 `서비스 수준에서의 분리`를 기본 정책으로 삼는 것.
- 그러나 필요치도 않은 서비스 경계를 처리하는 데 상당한 비용이 발생할 수 있다는 단점이 있음.


- 저자는 컴포넌트가 서비스화 될 가능성이 있다면 다음과 같이 대응:
  - 컴포넌트 결합을 분리하되
  - 서비스가 되기 직전에 멈춤
  - 그리고 컴포넌트들을 가능한 한 오랫동안 동일한 주소 공간에 남겨둠.
  - --> 서비스에 대한 선택사항이 열려있게 됨.

저자의 방식을 선택할 경우 다음과 같은 흐름이 발생:
> <U>초기:</U> <br/> 컴포넌트를 소스 코드 수준에서 분리
> 
> <U>배포나 개발에서 문제가 생김:</U> <br/> 일부 결합을 배포 수준까지 분리해 대응 
> 
> <U>개발, 배포, 운영적인 문제가 증가:</U> <br/> 서비스 수준으로 전환할 배포 단위들을 신중히 선택한 후 시스템을 (서비스화 하는 방향으로) 변경해 나감
> 
> <U>운영 요구사항이 감소:</U> <br/> 서비스 수준에서 분리되어있던 것들이 배포, 혹은 소스 수준의 분리만으로 충분해질 수 있음.

## 결론:
- ### 결합 분리 모드를 배포 / 운영 상황에 따라 선택할 수 있는 아키텍처를 구현해야 한다.
- 근데 좀 어렵다.
- 하기 싫으면 뛰어난 아키텍트가 되지 않으면 된다.

---

# 질의응답

```text
지인: 164~165p에 결합 분리 모드 중
배포 수준 분리 모드와 서비스 수준 분리 모드가 헷갈립니다.
jar 자체가 서비스라고도 볼 수 있다고 생각했는데... 글을 읽으면 또 아닌거 같고...
이에 대해서 예시를 들어주시거나 설명해주시면 좋을거 같네요 :)

대답:  물론 저도 헷갈립니다만, 일단 제가 생각하는 답변을 드리자면...

서비스 수준 분리 모드는 이름 그대로 분리된 개체가 단독으로 하나의 서비스를 수행할 수 있는 반면, 배포 수준 분리 모드에서 분리된 개체는 그렇지 않다고 할 수 있을 것 같습니다.

서비스 수준 분리에 대한 예시를 찾아보면 주로 Microservice에 대한 이야기가 많이 보이는데요, 사실상 서비스 수준 분리는 Microservice 아키텍처와 동일하게, 혹은 거의 유사하게 취급되는 것으로 보입니다. 해서 Microservice 아키텍처의 유명한 예시로는 역시 AWS 아키텍처가 있는데, [AWS 아키텍처 강연 4:16](https://youtu.be/_8ylg-DLnBY?t=256) 즈음에 나오는 그림을 보면, 하나의 microservice가 고유의 Data Store, Application/Logic을 가지고 있는 것을 볼 수 있습니다. 그리고 4:58 쯤으로 가시면 Amazon.com의 예시가 나오는데, 상품 설명/구매/이미지/장바구니 등의 요소들이 각각의 microservice 라는 것을 알려줍니다. 이렇게 독립적으로 하나의 서비스를 수행하는 개체들은 네트워크 API를 통해 통신하기 때문에, 동일한 저장소(주소 공간)에 존재할 필요 없이 별도의 서버에서 구동이 가능합니다. 이렇게 되면 유지보수와 배포 또한 더더욱 독립적이 되겠죠?

배포 수준 분리 모드를 위와 비교하자면 다음과 같은 주요 차이가 있다고 할 수 있습니다:
1 - 분리된 컴포넌트들이 동일한 주소 공간에 존재함(따라서 네트워크 통신이 아닌 함수 호출 등을 통해 서로 통신)
2 - 지인님께서 말씀하신 jar파일 같은 개체는 독립적으로 "실행"은 가능하겠지만, 그 자체로 "서비스"라고 보기는 어려움. (강연에서 나온 microservice를 예시로 들자면 jar 파일이 Application/Logic이 될 수 있겠지만 Data Store는 없다고 할까요?)

일단 둘의 차이를 비교하자면 위와 같습니다만... 저는 책에서 '모드'라고 하는 것이 부적절한 것이 아닌가 하는 생각이 듭니다. 마치 3가지 모드들이 스위칭되며 한 번에 한 가지만 사용되는 것 같은 느낌이 들기 때문이죠.
제 생각에 서비스 수준 분리 모드와 배포 수준 분리 모드는 다른 수준의 분리 같습니다.
예를 들어, 서비스 수준에서 분리된 개체의 Application/Logic이 배포 수준으로 분리되는 겁니다. (위에 링크된 강연에서 Application/Logic은 code, libraries, etc.. 라고 적혀있는 것을 보아, 충분히 가능할 것 같습니다) 이것이 맞다면 배포 수준 분리 모드는 서비스 수준 분리 모드보다 더 좁은 관점에서의 분리라고 할 수 있겠네요.
다만 이건 어디까지나 제 생각이고, 별로 확신은 없습니다. 다른 분들의 의견을 들어보고싶네요.

```

```text
하진: 컴포넌트 분리나 결합 분리 모드 등에 관해, 이들에 대해 의사결정할 때 정량적으로 접근한 시도가 있을지 알 수 있을까요?

대답: 정량적으로 접근한다는 게 어떤 의미로 말씀하신 건지 잘 모르겠네요.

이전에 지인님께서 소개하신 "안정성 지표"나 "컴포넌트의 추상화 정도" 같은 지표들을 활용하는 것을 말씀하시는 것이라면, 저는 본 적이 없다고 말씀드리겠습니다.
물론 없을 것이라는 게 아니라 그냥 제가 본 적이 없다는 것입니다.

그래서!
하진님이 좋아하시는 [논문](https://scienceon.kisti.re.kr/srch/selectPORSrchArticle.do?cn=JAKO200612842606841&dbt=NART)을 찾아왔습니다.

첫 장을 넘기자 노도와 같은 두통이 찾아와서 꼼꼼히 읽어보지는 않았습니다만... 하진님께서 말씀하신 정량적 접근의 사례라고 생각됩니다. 스터디에서 다같이 한번 읽어보도록 하죠.

```

```text
진영: 팀 개발 규모에 따라서 아키텍처가 달라질수 있다고 책에서 소개하는데 
저희 회사에서는 대부분 팀 규모가 프로젝트별로 3~4명 정도인걸로 알고있습니다.
그런상태에서는 모노리틱 아키텍쳐를 가져간다고 설명하는데.. 그러면 저희도 컴포넌트 분리를 안하고
모노리틱 구조로 가져가는게 오히려 개발의 속도가 유연성이 올라가게 될까요?

대답: 저도 그런 생각이 들기는 했는데...

아무래도 팀 인원 뿐 아니라 개발하는 소프트웨어(시스템)의 규모도 고려해야 하지 않나 싶습니다.
사실 스마트차트가 모노리틱이 더 효율적이라 하기에는 조금 복잡하고(물론 다른 프로그램을 충분히 접해보지 못해 객관적인 판단은 아닙니다), 비즈니스 로직도 계속해서 추가되니까요.

그런 관점에서 생각하면 저희는 모노리틱 아키텍처보다 컴포넌트 분리 등 책에서 말하는 "클린 아키텍처"를 지향하는 게 장기적으로는 개발의 속도와 유연성에 도움이 될 것 같습니다. 실제로 현재 계층 결합 분리를 진행하면서 코드의 가독성이 향상되는 등 분리 아키텍처의 장점이 느껴지고 있는 것 같지 않나요?



```

```text
규훤:
143p 아래 부분에서, 팀의 크기와 구성에 따라 아키텍처를 적용하는 것이 무조건 좋다고는 할 수 없다고 나와 있는데,
이것에 대한 기준이 궁금합니다.

모바일 파트는 4명으로 구성된 소규모 팀임에도 불구하고, 아키텍처를 적용했을 때의 장점을 느끼고 있다고 생각하는데,
지금 느끼고 있는게 아키텍처의 장점이 아니라, 앞에서 봤던 원칙들이 지켜지면서 느낀 것일 수도 있다는 생각이 드네요.

대답: 구체적인 기준은 저도 잘 모르겠습니다.
하지만 "일례로 팀이 개발자 다섯 명으로 구성될 정도로 작다면, 잘 정의된 컴포넌트나 인터페이스가 없더라도 서로 효율적으로 협력하여 모노리틱 시스템을 개발할 수 있다."라는 발언을 보면 어느정도 추측할 수 있을 것 같습니다.

제게 "서로 효율적으로 협력한다"는 말은 "서로의 작업을 아는 상황에서 개발한다"는 의미로 들립니다. 
만약 소규모 팀이 처음부터 아키텍처를 적용한다면 - 예를 들어 컴포넌트 분리를 착실히 한다면 - 각 개발자는 서로의 개발에 간섭하지 않고 독립적인 컴포넌트를 만들어 낼 것입니다. 그리고 그러한 컴포넌트들을 통합하는 메인 컴포넌트 또한 만들어야 할 것입니다.

그런데 만약 해당 팀이 소규모 프로그램을 만들 경우, 만들어진 컴포넌트들을 통합하는 것이 불필요한 비용으로 느껴질 수 있다고 생각합니다. 처음부터 "효율적으로 협력"하여 서로가 작업하는 시스템의 구성요소들을 인지하고 연결지어 개발한다면, 추상적인 통합을 생각할 필요가 없으니까요. 물론 이것은 구성요소들을 연결지어 개발하는 것이 어렵지 않은, 즉 시스템이 그정도로 복잡하지 않은 상황임을 가정한 것입니다.

따라서, 규훤님이 말씀하신 저자의 발언은 컴포넌트 분리와 통합이 "불필요한 수고"로 느껴질 만큼 시스템의 규모가 작을 경우를 겨냥한 것이라고 생각합니다. 다만 해당 경우도 초기 개발 이후 배포/유지보수/추가 개발 과정에서 시스템의 규모가 커진다면 아키텍처의 부재로 인한 어려움을 겪겠죠.

그리고 모바일 파트의 경우, 저는 충분히 아키텍처의 장점이 발휘되고 있다고 생각합니다. 정확히 말하자면 '우리는 계층 결합 분리' 단계를 거치고 있고, 그로 인한 장점을 느끼고 있는 것이겠지요. 
다만 저희가 지금까지 한 작업의 상당부분이 레거시 코드 개편이고, 책의 앞부분에 나온 원칙들을 지켜가면서 코드가 "깔끔"해진다는 점에 주목하면 아키텍처보다 원칙들을 지키는 것의 장점처럼 보일 수 있을 것 같습니다.
그런데 원칙을 지키는 것이 곧 아키텍처를 형성하는 것의 일부라고 생각하면 둘을 구분해서 생각할 필요가 있나 싶기도 하네요.

책의 뒷부분에 나오는 배포/유지보수 관점에서 아키텍처의 장점을 느끼려면 배포 수준 분리 같은 단계를 거쳐야 할텐데, 저희는 아직 그 단계가 아니라서 아키텍처의 장점이 온전히 드러나고 있지 않은 것일 수도 있고요.
```

```text
진호:
제가 '정책'이 무엇인지 잘 이해하고 있는지 모르겠네요.
책의 소규모 예시들을 보면 '자기테이프와 입출력 장치와의 연결', '이름과 주소 레코드에 대한 서식',
'디스크에 레코드 데이터를 저장' 같이 기획 혹은 프로그램의 목적에 가까운 개념인데
지금 몸담고 있는 모바일 프로젝트같이 비교적 더 큰 곳에서의 정책에 대해 설명해주실 수 있을까요?

대답: 우선 146p~147p를 보면 책에서 말하는 "정책"에 대한 정의가 나와있습니다.

> "정책 요소는 모든 업무 규칙과 업무 절차를 구체화한다"

이 말을 보면 정책이 앞서 언급되던 "행위"와 유사해 보이기도 합니다.
따라서 진호님이 말씀하시는 "프로그램의 목적"과도 의미가 통한다고 할 수 있겠네요.

혹은, 소프트웨어 시스템의 또다른 주요 구성요소인 세부사항과 대조되는 것으로서 생각해 볼 수도 있을 것 같습니다. 책에서 "고수준의 정책"이라는 표현이 등장하는데, "저수준의 정책"과 같은 표현이 등장하지 않는 것으로 보아 "고수준의 정책"과 "저수준의 세부사항"을 의미하는 것으로 보는 것이 맞을 것 같습니다. 실제로 책에서 뚜렷하게 정책과 세부사항을 대조하고 있기도 하고요. 그래서 세부사항을 저수준, 즉 코드라고 생각한다면 정책은 **코드로 구현해야 할 소프트웨어의 기능(비즈니스 로직) 그 자체**라고 할 수 있겠습니다.

일단 정책이 그렇다는 가정 하에, 스마트차트의 정책은 아래와 같다고 생각할 수 있겠네요.
- 애플리케이션 로그인
- 병원에 등록된 환자 조회
- 진료 대기중인 환자 조회
- 환자의 정보 조회
- 환자의 진료 기록 조회
- 의료 차트 읽기 (보기)
- 의료 차트 쓰기 (수정, 저장)
- 그 외 다수
= 사실상 스마트차트가 지원해야 하는 기능을 써 놓은 것입니다.

질문에서 벗어나는 것 같긴 하지만 이왕 예시가 있으니 책의 내용을 예시와 함께 살펴보면 좋을 것 같습니다.
이 중에서 차트 읽기/쓰기 항목을 가지고 생각 해 보자면, 해당 기능을 만들 때 "세부사항에 대한 선택을 미뤄둔다"는 것은 아마 아래와 같을 것입니다:
- 차트를 어디에 저장할 것인가 (기기 내부, 로컬 DB, 클라우두 DB, ...)
- 저장되는 차트의 형식은 무엇인가 (PNG, JPEG, PDF, ...)
- 차트 이미지를 어떻게 불러올 것인가 (TCP, HTTP, ...)
- 기타등등
위와 같은 사항은 정책에 영향을 주어선 안됩니다. 예를 들어 차트를 PNG로 저장한다고 해서 차트를 읽고 쓰는 것이 PDF로 저장할 때와 달라질 이유가 없는 것 처럼 말이죠. 마찬가지로 차트 파일을 로컬 DB에 저장하든 S3에 저장하든 기기에서 해당 파일을 불러와 읽기/쓰기 기능을 제공해야 하는 것은 변하지 않습니다.

이렇게 세부사항을 나중에 결정하도록 한다면 정책을 생성함에 있어 자유도가 높아지고, 추후 세부사항을 결정할 때 여러 선택지를 비교하며 정책들에 종합적으로 어울리다 생각되는 선택을 내릴 수 있겠죠? 더 나아가 세부사항의 변경이 쉽도록 설계한다면 운영 정책에 변경사항이 생겨도(ex. 로컬 DB 대신 AWS S3를 사용한다던가) 원활한 대응이 가능할 것입니다.

그래서 책에서는 세부사항의 결정을 최대한 미뤄야 한다고 하는 것 같네요.

```

```text
준우: 158p 콘웨이 법칙의 실제 사례를 좀 보고 싶네요

대답: 간결하지만 강렬한 질문이네요.
우선 책에서 말하는 콘웨이 법칙은
> "시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다."
입니다. 팀의 구성이 소프트웨어의 아키택처에 영향을 준다는 말 처럼 들리네요.

그런데 제가 구체적인 예시를 들기는 어려울 것 같습니다. 다른 회사의 프로그램 아키텍처와 팀 구성까지 자세히 알기는 어렵기 때문에...

그래서 저는 우리 전-능 아이티를 끼워맞춰 보기로 했습니다. 재미삼아 읽어주세요.
단, 안타깝게도 긍정적인 예시는 아닙니다. 

일단 제가 찾은 [예시](https://yozm.wishket.com/magazine/detail/1494/)에서 눈길을 끄는 문장을 하나 짚어보자면 "결합도가 낮은 조직에서 개발된 제품이 결합도가 높은 조직에서 나온 제품보다 훨씬 더 모듈화되어있다" 입니다. MIT와 하버드의 공동 연구에서 나온 말이라니 왠지 신뢰도가 하늘을 찌르네요.

이 말을 전능아이티에 개발팀에 대입해봅시다. 저의 팀의 결합도는 낮을까요 높을까요? 저는 (모바일 파트의 입장에서) 둘 중에 고르자면 "높다" 라고 하겠습니다. 왜냐하면 다른 팀(CRM, NC, 심지어 Web쪽 까지)에게 영향을 많이 받기 때문이죠.
모바일파트의 일원이라면 잘 알고 있을 겁니다. 준호 파트장님이 다른 파트에서 생긴 변경사항으로 인해 발생하는 이슈에 시달리는 것을요.

그리고 이제 스마트차트(전능아이티의 서비스)의 모듈화 정도를 생각해봅시다. 지금은 규훤님의 지도 아래 점점 발전하고 있지만, 규훤님이 오시기 전에는 저희에게 모듈화란 있을 수 없는 것이었습니다. 많은 팀에서 영향을 받다 보니 이슈가 많이 발생했고, 이에 대응하기에 급급하다 보니 프로그램의 확장성이나 응집성을 향상시키는 것 보다 요구사항을 맞추는 데에 더 집중했기 때문이죠. 결국 domain, presentation, data, network 등의 레이어 분리는 존재하지 않을 뿐더러 view 쪽에 presentation, data, network 등의 요소가 한방에 때려박힌, 규훤님께서 경악하셨던 구조가 탄생하게 된 것이었습니다. 팀이 서로 의존하니 코드도 서로 의존하는 기묘한 상황이랄까요? 
이러한 상황에 아무것도 모르는 제가 들어와서 그 구조를 그대로 답습하다보니 더 악화된 부분이 있지 않나 싶습니다.

그래서 스마트차트는 확장성이 높지 못하다고 할 수 있습니다. 다른 서비스에 직간접적으로 의존하는 부분이 많기 때문에 기능 하나 추가하려면 상당한 노력이 필요하기 때문이죠. 이를 결합도가 높은 조직이 모듈화를 잘 하지 못하는 예시라고 끼워맞출 수 있을 것 같습니다. 좋은 예시는 아니지만, 얼추 비슷해서 한번 적어봤습니다.

```

```text
이영:책 159p에 몇몇 아키텍처 원칙은 구현하는 비용이 비교적 비싸지 않으며, 관심사들 사이에서 균형을 잡는데 도움이 된다고 했는데, 
이에 해당하는 아키텍처 원칙은 무었이 있나요??

대답: 원칙이 워낙 많기도 하고, 비용의 높낮음을 결정하는 기준이 뚜렷하지 않아 선뜻 답변을 드리기가 어렵네요.

일단 제 생각을 말씀드리자면, 아무래도 적용 규모가 작은 원칙들이 구현 비용이 낮지 않을까요?
예를 들어 공통 폐쇄 원칙(CCP)이나 공통 재사용 원칙(CRP)은 단순히 클래스 파일들의 재배치만으로도 구현이 가능할 것입니다. 물론 클래스들이 SOLID원칙을 준수하여 각각 분명하게 역할이 구분 된 이상적인 상황이라는 가정 하에 말이죠.

반대로 적용 규모가 큰 원칙은 구현 비용이 높을 것입니다.
예를 들어 의존성 비순환 원칙(ADP)을 구현하기 위해서는 모든 컴포넌트의 존재와 각각의 역할을 파악해야만 하고, 단순 코드 뿐만이 아니라 데이터베이스나 사용자 인터페이스 등의 사항도 고려해야 하므로 원칙 구현 비용이 결코 적지 않을 것입니다.

제가 너무 단순하게 생각한 건 아닌가 하는 의문이 듭니다만, 제가 생각할 수 있는 건 여기까지인 것 같습니다.
다른 분들의 의견을 더 들어보면 좋을 것 같네요.

```

```text
영재: 책 158쪽 위에 "시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다"는 말이 있는데요, 
이 말의 의미가 팀 간 소통 -> 컴포넌트 간 소통 의 의미인지, 아니면 독립된 팀 -> 독립된 컴포넌트의 의미를 가지고 있는지, 둘 다인지 궁금합니다. 

대답: 질문이 잘 이해되지 않습니다.
구체적으로는, "팀 간 소통" 과 "독립된 팀"이 따로 볼 수 있는 것인지 잘 모르겠습니다.

제가 이렁게 생각하는 이유는 위에서 말하는 "소통"이 단순히 대화를 나눈다는 것이 아니라, 시스템에 대한 의견을 교환하고 그로 인해 서로의 의사결정에 영향을 주는 것에 가깝다고 생각하기 때문이죠. 따라서 팀 간 소통이 활발하다면 팀의 독립성은 낮아지는 것이 아닐까 합니다.

"컴포넌트 간 소통"도 컴포턴트들의 통신 방식을 말씀하시는 것인지, 아니면 컴포넌트들의 의존관계를 말씀하시는 것인지 잘 모르겠습니다.

일단 콘웨이의 법칙에 대한 전반적인 이해가 더 필요할 것 같은데... 저는 좋은 답변을 드리기가 어렵네요.
다른 분들의 의견을 들어보고 싶습니다.
```

```text
가온: 147쪽("선택사항 열어두기")에서 개발 초기에는 DB, WEB서버, REST 등을 선택할 필요가 없다고 나와있습니다. 맨뒤에 있는 30장~32장에도 DB, Web 서버, 프레임워크 등은 아키텍처가 아니라 세부사항이라고 나와있습니다. 즉, 아키텍처와 같은 고수준의 정책에서는 이러한 것들에 최대한 의존하지 말자는 것이 결론인듯한데요. DB에 관심이 있는 사람으로서(?ㅎㅎ) 관련한 질문이 하나 있습니다.

"고수준의 정책을 데이터베이스 관계형인지, 분산형인지, 계층형인지, 아니면 평범한 플랫 파일인지와는 관련이 없도록 만들어야 한다."

개발 환경에서 위와 같이 데이터베이스의 형태에 관해 어떤 환경에서 어떤 구조의 DB를 써야 하는지에 관한 예시가 궁금합니다.(e.g. "언제 플랫 파일을 쓰는가?")

대답: 저는 DB에 관심이 없...다기보다는 잘 모릅니다.

그래도 답변을 해 보자면, 시스템의 "운영" 관점에서 결정해야 할 사항이 아닌가 싶습니다.
책의 예시처럼 시스템을 초당 100,000명의 고객을 처리해야 한다면 조회 속도가 빠른 데이터베이스를 사용하는 것이 유리할 것이고,
시간당 처리량은 적으나 데이터의 변동성이 높을 경우 확장성이 높은 데이터베이스를 쓰는 것이 유리하지 않을까요?

플랫 파일 사용의 예시인지는 확신하지 못하겠지만... 제 경험을 하나 공유하자면:
제가 해본 게임중에 아이템 정보를 json 파일로 저장하는 게임이 있었는데, 해당 파일을 열어서 아이템 정보를 수정하며 놀았던 기억이 있습니다.
이러한 데이터 사용 방식의 장점은
- 사용이 매우 간편함
- 규모가 작은 시스템에 효율적
등이 있을 것입니다.

그러나 제가 해당 파일을 무단으로 수정할 수 있었던 것처럼 보안 기능이 전무하다시피 하고, 원거리에서 실시간으로 관리하는 것이 사실상 불가능하다는 단점들 또한 있습니다.

하지만 제가 했던 게임은 싱글플레이어 게임이고 단순히 재미를 추구하는 것이니, 상기한 단점이 개발자에게 별로 중요하지 않게 느껴졌겠죠? 이를 통해 말씀드리고 싶은 것은, 시스템의 운영에 적합한 DB를 고르면 된다는 것입니다.

제가 DB 종류나 구조를 잘 몰라서 좋은 답변을 드리지 못하는 점 양해바랍니다.
스터디 할 때 잘 아시는 분들의 의견을 들어보기로 하죠.

```
