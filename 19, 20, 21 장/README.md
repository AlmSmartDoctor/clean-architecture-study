# 진행 자료

진행자료 작성 전 질의응답에서 본인 이름은 삭제 후 진행해주세요.

---

# 질의응답

```text
지인: 209p에서 "좋은 소프트웨어 아키텍처는 프레임워크, DB, 서버 등에 대해서 결정을 미룰 수 있게한다."
라고하는데 DB, 서버까지는 이해를 하지만 프레임워크 결정을 미루는 건 대체 어떻게 하는건지 감이 안잡히네요.
예시 하나만 들어주세요~~

대답: 프레임워크 없이 개발하는 것은 불가능에 가깝지요. 특히 오늘날의 프레임워크는 무척 강력하니까요 ㅎㅎ

이 챕터에서 저자가 주장하고자 하는 것은, 프레임워크의 결정을 미룬다보다는, 유스케이스가 프레임워크에 구애받지 않아야 한다에 가깝기는 합니다.
- 유스케이스가 프레임워크에 좌우되어서는 안 된다.
- 프레임워크를 갖고 개발을 하고 있더라도, 프레임워크에 의존적인 부분을 전부 제거하고(혹은 mocking하고) 단위 테스트를 했을 때 잘 돌아가야 한다.
- 아키텍쳐는 프레임워크가 아니라 유스케이스를 잘 드러내야 한다.

이전 발표에서 소개된 것처럼, 심지어는 프레임워크를 변경하는 것에도 (그 과정은 아주 고통스럽겠지만) 열려있어야 한다는 구절과 일맥상통한다고 볼 수 있겠습니다.

자동접수의 경우, 접수 관련 코드를 TypeScript, NestJS 로 작성했었고, 그 후 Kotlin, Spring Boot 로 이전했습니다.
이때 로직과 관련된 부분은 (언어에는 의존적이었지만) 프레임워크에 의존하지 않았으므로, 몇몇 DB 조회 로직을 제외하면 큰 공수 없이 이전할 수 있었습니다.
```

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진영: 책에 정책에 대한 설명을 보면 컴포넌트처럼 취급하고, 실제로 수준을 나눠서 쓰는걸 보면 컴포넌트라는 느낌이 강한데,
또 책에 적힌 설명을 보면, 컴포넌트들의 집합이 또 정책이라고 보인단 말이죠..
컴포넌트랑 정책에 대한 구분이 명확히 안되는데, 정책과 컴포넌트의 확실한 차이점을 설명해주실수있나요?

대답: 컴포넌트는 배포 수준입니다.

정책은 추상적인 단위입니다. 일반적으로는 이렇게 정의 또는 해석하는 것 같더군요.
- 정책(policy): 보통 회사나 팀의 경영자 또는 결정권자가 초기에 결정하는, 돈을 버는 방법. 사업이 피벗되는 게 아닌 이상 보통 잘 변하지 않습니다.
- 비즈니스 규칙(rule): 정책을 조금 더 도식화한 것. (드물게, 정책과 비슷하거나 같은 것이라 보는 경우도 있습니다.)
- 비즈니스 로직: 비즈니스 규칙을 절차적, 명령적으로 구현한 것

여러 정책을 묶어서 하나의 컴포넌트로써 구현하거나, 혹은 정책의 수준이 다르거나 변경 양상이 다르면 서로 다른 컴포넌트에 넣을 수 있겠습니다.
```

```text
규훤:
실제 작업에서 엔티티의 핵심 업무 규칙과 유스케이스의 차이를 잘 모르겠습니다.

저는 보통 클아를 적용할 때, 퓨어한 Model과 Model을 다루는 UseCase를 같은 모듈(컴포넌트)에 두는데,
책에서 말하는 Model은 퓨어하지 않고 함수(핵심 업무 규칙)를 가지고 있더라구요.

혹시 가능하다면 예시 코드도 보고 싶습니다ㅎㅎ

대답: 저자 블로그의 글에서는 포인트를 enterprise-wise냐, application-specific냐를 강조하고 구분하더군요.
http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

![](http://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg)

전제
- Enterprise(뜻: 사업, 기업, 그것들의 경영 방법)은 여러 application으로 구성될 수 있습니다.

Entities
- Enterprise-wise business rules를 캡슐화하는 단위입니다.
- 메소드를 갖는 객체의 집합일 수도 있고, 또는 자료구조(DB 스키마라고 보시면 되겠습니다)와 함수의 집합일 수도 있습니다.
- 가장 일반적이고, 고수준입니다.
- 외부에 변화에 가장 둔감합니다.
- Enterprise가 딱히 없고 single application을 작성하는 경우, entites가 application의 business objects가 됩니다.

Use cases
- Application-specific business rules를 캡슐화하는 단위입니다.
- Entities로의/부터의 데이터 흐름을 조작해서, 또한 entities에 명령을 내려서, enterprise-wide business rules를 use case의 목적을 성취하는 데 사용합니다.
- 이 계층이 변화하더라도 Entities에 영향을 주지 않을 것이라 기대할 수 있습니다. 또한 DB/UI/framework와 같은 외부의 것들이 변화해도 이 계층은 영향을 받지 않을 것이라 기대할 수 있습니다. (관심사 분리)
- Application의 operation(운영 또는 동작?)에 변화가 발생할 경우 이 계층은 영향을 받을 수 있습니다. 즉슨, use cases의 details가 변화할 경우 이 계층의 일부 코드는 영향을 받을 수 있습니다.

그래서 entity와 use case가 둘다 business rules의 추상화 단위이지만, 이러한 차이를 두고 구분되며,
이에 관련해 Model class가 메소드를 갖거나, 혹은 로직이 함수 형태로 존재하느냐는 별로 상관하지 않는 것 같더군요.
```

```text
진호: p.210 프레임워크는 도구일 뿐, 삶의 방식은 아니다
지금까지 책을 봐오면서 아키텍처는 결국 의존성 관리라는 생각이 듭니다.
프레임워크와 아키텍처를 분리할 수 있다는 것은
프레임워크가 디렉토리와 소스 코드 구조를 강제하더라도
의존성 관리는 결국 프로그래머가 하는 것이므로
분리할 수 있다고 보는데 맞나요?

대답: 아키텍처의 정의에 의존적인 질문입니다.
소스코드 파일의 구조는 프레임워크에 어느 정도 좌우되지만, 더 나은 구조를 위해 세부적인 것들을 결정하는 것은 개발자의 몫입니다. (분리할 수 있습니다.)
```

```text
천규: 
21장의 끝부분에서 "... 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를
할 수 있어야 한다." 라는 말이 있는데, 이 말이 구체적으로 무엇을 의미하는지 잘 모르겠습니다.
제가 생각하는 것은:
    1) 프레임워크로 구성될 부분이 전혀 없이도 유스케이스에 대해 단위 테스트가 가능해야 한다.
    2) 프레임워크로 구성될 부분을 간단한 코드로 구성한 후 테스트가 가능해야 한다.
인데, 위 2가지 중 하나인지, 혹은 전혀 다른 의미인지에 대해 결론을 내리기가 힘드네요.

그리고 사실 프레임워크를 적용하는 부분이 어느정도인지도 잘 모르겠습니다.
엔티티나 유스케이스를 제외한 모든 곳에 프레임워크 적용이 가능한 것인가요? 아니면
엔티티/유스케이스와 같은 중심에서 가급적 멀리 떨어진 부분(세부사항)에 프레임워크를 적용해야 하나요?

대답: 다른 질문과 유사하여 답변을 생략하겠습니다 :)
```

```text
준우: 208p에서 애플리케이션의 아키텍처가 뭐라고 소리치는가라고 질문했을 떄 "최상위 패키지의 소스를 보고 과연 도메인을 바로 파악하는게 가능할까"?라는 의문이 듭니다. 물론 이상적인 아키텍처라면 저자의 말대로 "스프링"이 아니라 "헬스 케어 시스템"이라는 사실에 좀 더 집중할 수 있어야 할텐데, 실질적으로 이게 가능한 소리인가 잘 이해가 안되네요.

대답: 제 생각에는, 최상위의 소스코드뿐만 아니라 더 넓은 관점인, 즉 아키텍쳐 관점까지 확장해야 하지 않을까 싶습니다.
해당 시스템을 처음 보는 개발자가, 아키텍쳐 관계도와 어느 정도의 소스코드 리딩으로 업무 규칙을 파악할 수 있다면, 그것이야말로 좋은 아키텍쳐라 부를 수 있을 것 같습니다 ㅎㅎ
```
```kotlin
@SpringBootApplication
@EnableTransactionManagement
@EnableCaching
class AutoReceiptApplication
fun main(args: Array<String>) {
    runApplication<AutoReceiptApplication>(*args)
}
```

```text
이영: 210쪽에 아키텍쳐가 유스케이스를 최우선으로 한다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위테스트를 할 수 있어야 한다고 했는데, 단위테스트는 어떤식으로 진행되는건가요?? 데이터베이스나 프레임워크 등 복잡한것들에 의존하면 안된다고 했는데 그럼 어떤식으로 테스트가 진행되느지 궁금합니다.

대답: 다른 질문과 유사하여 답변을 생략하겠습니다 :)

Refer to - https://github.com/AlmSmartDoctor/backend-spring-boot-study/blob/main/3.%20%EC%8A%A4%ED%94%84%EB%A7%81%20%EB%B6%80%ED%8A%B8%20%ED%85%8C%EC%8A%A4%ED%8A%B8/SpringBootTest/src/test/kotlin/com/example/springboottest/bookRestTest/BookRestTest.kt
```

```text
영재: 21장 전체에서 이야기하는 내용에 대한 질문인데, 
요약하자면 유스케이스만으로 아키텍처를 모두 설계(DB, 프레임워크 등에 대한 고려 없이) 한 다음,
테스트(마찬가지로 DB, 프레임워크 등 없이) 한 다음,
그때부터 설계한 내용을 구현해야 한다는 뜻인가요?
어차피 구현 할 때나, 다 구현하고 나면 테스트를 필수적으로 해야 할 텐데, 
앞에서 말한 작업이 구현하는 것과 그 다음 테스트할 때 쉽게 할 수 있어서 
결국엔 비용을 줄여줄까요? 
앞에서 말한 작업으로 인해 너무 비용이 커지는 건 아닐지 궁금합니다. 
(유스케이스만으로 모두 설계 후 테스트 -> 구현 -> 또 테스트)

대답: 제 생각에는, 테스트에 대한 부분을 조금 강하게 해석하신 것 같습니다.
TDD(Test-Driven-Development, 테스트 주도 개발)이라고, 말씀하신 사항에 상당히 부합하는 개발론이 있습니다.
저는 적용해본 적이 없지만, 대략 테스트 코드를 먼저 작성하고 그에 부합하는 코드를 작성하는 구조입니다.
저자가 TDD를 쓰라고 명시적으로 권하지는 않았지만요 ㅎㅎ
```

```text
가온: p.210 에서 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다고 했습니다.
지금 회사에서 개발하는 과정에서만 봐도 프론트에서 만든 웹이나 Postman 등으로, 즉 웹 서버를 거의 반드시 이용하여 테스트를 진행을 하고 있습니다.
단위 테스트라는 것이 각각의 API? 같은 각각의 유닛 하나하나를 개별적으로 테스트한다 라는 뜻으로 해석했는데, 제 이해가 올바른지 궁금합니다.
"테스트는 단위 테스트와 통합 테스트 등으로 나뉜다."라는 맥락에서 단위 테스트인 것 같은데 일반적으로 실무 개발에서 단위 테스트는 어떻게 하나요?
책에 나오는 내용대로 웹, DB 등의 (책에서 주장하는) 세부사항과 무관하게 테스트하는 것이 어떻게보면 이상적이라는 생각이 들어서요.
(물론 뒤에 제가 맡은 부분에서도 DB, 웹, 프레임워크 등은 아키텍처 레벨에서 세부사항이라는 말은 일관되게 나옵니다.)

대답: 단위(unit) 테스트란 테스트 가능한 가장 작은 단위들을 테스트하는 것을 말합니다.
보통 함수/메소드 하나하나, 클래스 각각을 테스트하는 것을 의미합니다.
필요한 경우 그 단위 내부에서 의존하는 대상을 mocking합니다.

이것보다 더 큰 개념으로 통합 테스트가 있습니다.
그래서 단위들을 모아서, 동작 하나가 잘 작동하는 겅것을 보는 것이지요.

말씀하신 것처럼 API 엔드포인트 하나가 온전히 작동하는지를 테스트하려면, 결국 그 엔드포인트가 작동하는데 필요한 구성요소들을 함께 작동시켜야 하므로 통합 테스트라고 볼 수 있겠습니다.
```
